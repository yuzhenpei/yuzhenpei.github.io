[{"title":"C语言进阶","url":"/2023/04/06/C语言进阶/","content":"### C进阶\n\n#### 数据类型\n\n+ 声明数据类型是为了更好的管理内存，为数据分配合理的内存空间\n+ 定义的数据都得有一种数据类型\n+ 创建变量的模具，**固定大小内存的别名**，即int a = 10；是分配一个4个字节的内存空间，里面存的数据为10(里面用16进制表示0)，然后用别名 a来操作这段内存\n\n#### typedef\n\n实际就是起一个别名来操作\n\n+ 简化结构体的struct关键字\n+ 区分数据类型   typedef char * Pchar;\n+ 提高移植性，当需要修改特定的时候 提前用typedef定义后只需要修改定义就行\n\n#### void\n\n+ 无类型   无法定义数据类型，编译器无法知道为数据分配多大的内存\n\n+ 限定函数返回值，限定函数参数\n\n+ 万能指针  void *p=NULL;(任何指针用sizeof调用都是四个字节)\n\n  不同类型的指针需要强转才能转换，void指针可以不通过强制类型转换\n\n#### sizeof\n\n+ 本质不是一个函数，而是一种运算符\n\n+ 在统计类型的时候需要加括号，在统计变量的时候可以不加括号\n\n+ sizeof的返回值是一个unsigned int  无符号整型\n\n  一个unsigned int 和int运算，结果会统一为unsigned int\n\n+ 可以求数组所占内存空间的大小\n\n  当一个数组名传入到函数中作为参数，会被退化为一个指针，这个指针指向该数组首元素的地址，其实数组名就是一个地址\n\n#### 变量的修改\n\n+ 变量本质：一段连续内存空间的别名\n+ 不是向变量名读写数据，而是向变量名所代表的内存空间进行读写数据\n+ 直接修改\n+ 间接修改 ： int *p=&a;   *p=20;// *p是解引用过程，是访问p内存存放的地址所代表的值\n\n#### 内存四区\n\n+ 运行之前：\n  + 预处理：宏定义展开，头文件展开，条件编译，这里并不会检查语法\n  + 编译：检查语法，将预处理后的文件编译成汇编文件\n  + 汇编：将汇编文件生成目标文件（二进制文件）\n  + 链接：将目标文件链接为可执行文件\n+ 代码区：存放cpu执行的机器指令。通常代码区是共享的，共享的目的是频繁被执行的程序只需要在内存中有一份代码就可以，代码区通常是只读的\n+ 全局初始化数据区或者叫做静态数据区（data段）：在程序中被明确初始化的全局变量，已经初始化的静态变量和常量数据\n+ 未初始化数据区（又叫bss区）：存入的是未初始化变量和未初始化静态变量，未初始化数据区在程序执行前被内核初始化为0或者NULL；\n\n+ 运行之后：\n  + 栈区：先进后出，编译器自动分配释放，函数的参数，返回值，局部变量，在生命周期结束的时候自动释放内存，栈容量有限，容易栈溢出\n  + 堆区：大容器，用于动态分配内存，堆在内存中位于bss和栈之间，一般由程序员分配和释放，程序结束时由操作系统回收\n\n#### 栈区的注意事项\n\n+ 在函数里面定义的局部变量不能作为返回值，因为在函数运行结束的时候栈中已经把局部变量的内存释放\n+ 不要返回局部变量的地址值\n\n#### 堆区以及注意的事项\n\n+ 使用 malloc关键字向堆申请内存空间，在使用完后建议free掉\n+ memset 为新申请的内存做初始化 memset（内存，0，大小）\n+ 主调函数里面的空指针，被调函数中用同级指针分配内存失败需要高级指针来修饰，在主调函数中把指针的地址传入进去\n\n#### 静态变量和全局变量\n\n+ 静态变量：static 关键字修饰\n  + 在程序执行前分配内存\n  + 生命周期为整个程序运行周期\n  + 默认属于内部链接属性，在当前文件夹里使用\n  + 还是跟其他变量的作用域规则一样\n+ 全局变量：\n  + 在C语言中的全局变量在类型前面默认加了一个extern关键字\n  + 属于外部链接属性\n  + extern int g_b；  告诉编译器  其他文件中有一个g_b  在链接的时候去别的文件中找\n\n#### const常量\n\n+ 全局的const 常量 ：\n\n  + 不可修改\t：放在常量区，受到常量区的保护，只具有读的操作\n\n+ 局部的const 常量 （伪常量） ：\n\n  + 不可直接修改，但是可以用指针间接修改\n\n    因为是局部变量 ， 是保存在栈中的，伪常量不可初始化数组\n\n#### 字符串常量\n\n+ char * p = \"hello world\";\n\n+ 相同的字符串常量，被不同的指针所指向，指针的地址值相等\n  + 字符串常量由编译器来决定是否可以修改 \n\n#### 宏函数\n\n+ 在预处理阶段就做了宏的替换\n+ 使用场景：短小且频繁使用的函数，封装为宏函数\n+ 优点：以空间换时间（普通函数的变量需要频繁入栈和出栈）\n+ 注意事项：运算的时候需要保证运算的完整性\n\n#### 函数的调用流程\n\n+ 记录函数的返回地址（在调用完子函数后，能继续执行主函数的后面的代码）\n+ 进栈，参数从左往右进栈\n\n#### 调用惯例\n\n+ 主调函数和被调函数之间需要有一个约定才能正确的调用函数\n\n+ cdecl C语言默认的调用惯例，参数传递从右到左参数入栈，出栈方是函数调用方，名字修饰用下划线加函数名\n\n#### 函数变量传递分析\n\n+ main函数在栈中开辟的内存，所有子函数都能使用\n+ main函数在堆中开辟的空间，所有子函数均可以使用\n\n#### 栈的生长方向\n\n+ 栈底是高地址，栈顶是地地址\n\n#### 内存存储方式\n\n+ 根据大端对齐模式还是小端对齐模式\n+ 大端对齐模式：高位字节数据放在内存低地址处\n+ 小端对齐模式：高位字节数据放在内存高地址\n\n#### 指针强化\n\n+ 指针是一种数据类型，占用内存空间，用来保存地址（任何类型的指针都只占四个字节的内存空间）\n+ 空指针：指向NULL   野指针：指向的内存不是自己申请的\n+ 不能向空指针和野指针指向的内存进行操作，如果操作，程序中断\n\n#### 野指针三种情况\n\n+ 指针没有进行初始化，就进行操作\n+ malloc后free后的指针    解决办法：指向NULL\n+ 指针变量超出了作用域\n+ 空指针可以重复释放，野指针不能重复释放\n\n#### 指针的步长\n\n+ 指针变量+1后跳跃的字节数\n+ 在解引用时候，取出的字节数\n+ 结构体中成员的偏移量 ： 用offsetof（结构体，成员名）宏函数; 需要导入头文件#include<stddef.h>\n\n#### 指针的间接赋值\n\n+ 间接赋值的三大条件：\n  + 两个变量（普通变量或指针变量，形参实参）\n  + 建立关系\n  + 通过*操作指针指向的内存\n\n#### 指针做函数参数\n\n+ 输入特性：主调函数分配内存，被调函数可以使用\n+ 输出特性：被调函数分配内存\n\n\n\n#### 字符串指针强化\n\n+ 注意事项：\n\n  + 字符串结束标志 \\0\n\n  + char str[] ={'a','c','\\0'}   这种需要在后面手动加上\\0结尾\n  + char str[10] = {'s','b'}   这种会自动给你加上\\0结尾\n  + char str = \"hello world\"  也是自动加上\\0    strlen() 不统计\\0   sizeof() 统计\\0\n\n#### 字符串拷贝\n\n+ 第一种：根据下标进行拷贝\n\n  ```c\n  void copyStringMethod1(char *dest,char *source)\n  {\n      int len = strlen(source);\n      for(int i =0;i<len;i++)\n      {\n          dest[i]  = source[i];\n      }\n      dest[len] = '\\0'; //把结束标志进行打上，避免外界数组没有进行初始化而导致乱码\n  }\n  ```\n\n+ 第二种：根据指针进行拷贝\n\n  ```c\n  void copyStringMethod2(char *dest,char *source)\n  {\n      while(*source!='\\0')\n      {\n          *dest = *source;\n          dest++;\n          source++;\n      }\n      *dest = '\\0';\n  }\n  ```\n\n+ 第三种：根据指针的简洁版\n\n  ```c\n  void copyStringMethod3(char *dest,char *source)\n  {\n      while(*dest++ = *source++);//当左值已经为0就不会再进入循环\n  }\n  ```\n\n#### 字符串反转\n\n+ 第一种：根据下标进行反转\n\n  ```c\n  void reverseString(char *str)\n  {\n      int len = strlen(str);\n      int start = 0;  //指向第一个\n      int end = len -1; //指向最后一个\n      while(start <end)\n      {\n          char temp = str[start];\n          str[start] = str[end];\n          str[end] = temp;\n          start++;\n          end--;\n      }\n  }\n  ```\n\n+ 第二种：根据指针进行反转\n\n  ```c\n  void reverseString(char *str)\n  {\n      int len = strlen(str);\n      char *start = str;  //定义一个指针,指向首地址\n      char *end  = str +len-1;  //加上偏移量 指向最后一个\n      while(start<end)\n      {\n          char temp = *start;\n          *start = *end;\n          *end = temp;\n          start++;\n          end--;\n      }\n  }\n  ```\n\n#### 字符串格式化\n\n+ int sprintf(char * str , const char * format,...), 失败返回-1，成功返回格式化字符个数\n\n+ 参数1：格式化的后的目标字符串 参数2：格式化形式  参数3：...  格式化中的参数\n\n  ```c\n  sprintf(buf,\"今天是 %d 年 %d 月 %d 日 \",2023,04,05);\n  ```\n\n+ 字符串拼接\n\n  ```c\n  char str[1024];\n  memset(str, 0, 1024);\n  char str1[] = \"hello world\";\n  char str2[] = \"yzpcode\";\n  sprintf(str, \"%s %s \",str1,str2);\n  ```\n\n#### calloc 和 realloc \n\n\n\n\n\n"},{"title":"springboot项目实战","url":"/2023/03/31/springboot项目实战/","content":"\n\n#### 创建项目和添加依赖\n\n+ **在线创建项目**\n\n  + 地址：https://start.spring.io/\n\n+ **添加依赖**\n\n  + springboot核心包\n\n    ```\n    <dependency>\n          <groupId>org.springframework.boot</groupId>\n          <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n          <groupId>org.springframework.boot</groupId>\n          <artifactId>spring-boot-starter-test</artifactId>\n          <scope>test</scope>\n          <exclusions>\n            <exclusion>\n              <groupId>org.junit.vintage</groupId>\n              <artifactId>junit-vintage-engine</artifactId>\n            </exclusion>\n          </exclusions>\n        </dependency>\n    ```\n\n  + mybatis依赖\n\n    ```\n    <dependency>\n          <groupId>org.mybatis.spring.boot</groupId>\n          <artifactId>mybatis-spring-boot-starter</artifactId>\n          <version>2.1.2</version>\n    </dependency>\n    ```\n\n  + mysql驱动（注意需要去掉runtime，否则会报错）\n\n    ```\n    <dependency>\n          <groupId>mysql</groupId>\n          <artifactId>mysql-connector-java</artifactId>\n    </dependency>\n    ```\n\n  + 通用工具包\n\n    ```\n    <dependency>\n          <groupId>org.apache.commons</groupId>\n          <artifactId>commons-lang3</artifactId>\n          <version>3.12.0</version>\n    </dependency>\n    ```\n\n  + 跨域身份验证解决方案 Json web token包\n\n    ```\n    <!-- JWT相关 -->\n    <dependency>\n          <groupId>io.jsonwebtoken</groupId>\n          <artifactId>jjwt</artifactId>\n          <version>0.7.0</version>\n    </dependency>\n    ```\n\n  + 高性能缓存组件\n\n    ```\n    <!--guava依赖包-->\n    <dependency>\n          <groupId>com.google.guava</groupId>\n          <artifactId>guava</artifactId>\n          <version>19.0</version>\n    </dependency>\n    ```\n\n#### 打通数据库\n\n+ **添加数据库配置**(在``application.properties``)\n\n+ 配置文件中添加)\n\n  ```\n  server.port=8081\n  \n  #==============================数据库相关配置========================================\n  spring.datasource.driver-class-name =com.mysql.cj.jdbc.Driver\n  spring.datasource.url=jdbc:mysql://localhost:3306/online_class_yzpcode?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8&useSSL=false\n  spring.datasource.username=root\n  spring.datasource.password=1234\n  #使用阿里巴巴druid数据源，默认使用自带的\n  #spring.datasource.type =com.alibaba.druid.pool.DruidDataSource\n  #开启控制台打印sql\n  mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl\n  \n  # mybatis 下划线转驼峰配置,两者都可以\n  #mybatis.configuration.mapUnderscoreToCamelCase=true\n  mybatis.configuration.map-underscore-to-camel-case=true\n  #配置扫描\n  mybatis.mapper-locations=classpath:mapper/*.xml\n  #配置xml的结果别名\n  mybatis.type-aliases-package=xyz.yzpcode.online_class.domain\n  ```\n\n#### 开启热部署和开发统一JSON数据格式工具类\n\n+ **热部署设置**\n\n  ```\n  <dependency>  \n           <groupId>org.springframework.boot</groupId>  \n           <artifactId>spring-boot-devtools</artifactId>  \n           <optional>true</optional>  \n    </dependency>\n    \n    \n    <build>\n          <plugins>\n              <plugin>\n                  <groupId>org.springframework.boot</groupId>\n                  <artifactId>spring-boot-maven-plugin</artifactId>\n                  <configuration>\n                      <fork>true</fork><!--必须添加这个配置-->\n                  </configuration>\n              </plugin>\n          </plugins>\n      </build>\n  ```\n\n  需要在``idea``中``compiler``开启 ``build project automatically`` 然后按住``shift+Ctrl+alt+/ ``选择``registry ``选择``auto when app running``然后重启``idea``即可\n\n+ **JsonData工具类**\n\n  ```\n  public class JsonData {\n  \n      /**\n       * 状态码  0表示成功   1表示处理中  -1表示失败\n       */\n      private Integer code;\n  \n      /**\n       * 业务数据\n       */\n      private Object data;\n  \n      /**\n       * 信息显示\n       */\n      private String msg;\n  \n      JsonData(){}\n  \n      JsonData(Integer code,Object data,String msg){\n          this.code = code;\n          this.data = data;\n          this.msg  = msg;\n      }\n  \n      /**\n       * 成功   不返回数据\n       * @return\n       */\n      public static JsonData buildSuccess(){\n          return new JsonData(0,null,null);\n      }\n  \n      /**\n       * 成功   返回数据\n       * @param data\n       * @return\n       */\n      public static JsonData buildSuccess(Object data){\n          return new JsonData(0,data,null);\n      }\n  \n      /**\n       * 失败    固定状态码\n       * @param msg\n       * @return\n       */\n      public static JsonData buildError(String msg){\n          return new JsonData(-1,null,msg);\n      }\n  \n      /**\n       * 失败   自定义状态码\n       * @param code\n       * @param msg\n       * @return\n       */\n      public static JsonData buildError(Integer code,String msg){\n          return new JsonData(code,null,msg);\n      }\n  \n      public Integer getCode() {\n          return code;\n      }\n  \n      public void setCode(Integer code) {\n          this.code = code;\n      }\n  \n      public Object getData() {\n          return data;\n      }\n  \n      public void setData(Object data) {\n          this.data = data;\n      }\n  \n      public String getMsg() {\n          return msg;\n      }\n  \n      public void setMsg(String msg) {\n          this.msg = msg;\n      }\n  }\n  ```\n\n#### 自定义异常\n\n+ 自定义异常  继承RuntimeException\n\n  ```\n  /**\n   * 自定义全局异常\n   */\n  public class YZPException  extends RuntimeException{\n  \n      private Integer code;\n  \n      private String msg;\n  \n      public YZPException(Integer code,String msg){\n          this.code = code;\n          this.msg  = msg;\n      }\n  \n      public Integer getCode() {\n          return code;\n      }\n  \n      public void setCode(Integer code) {\n          this.code = code;\n      }\n  \n      public String getMsg() {\n          return msg;\n      }\n  \n      public void setMsg(String msg) {\n          this.msg = msg;\n      }\n  }\n  ```\n\n+ 开发异常处理器 ExceptionHandle\n\n  ```\n  /**\n   * 异常处理类\n   */\n  @ControllerAdvice\n  public class CustomExceptionHandler {\n  \n      private final static Logger logger =  LoggerFactory.getLogger(CustomExceptionHandler.class);\n  \n      @ExceptionHandler(value = Exception.class)\n      @ResponseBody\n      public JsonData handle(Exception e){\n          logger.error(\"[ 系统出错 ] \",e);\n          if( e instanceof YZPException){\n  \n              YZPException yzpException = (YZPException) e;\n              return JsonData.buildError(yzpException.getCode(),yzpException.getMsg());\n          }else{\n              return JsonData.buildError(\"全局异常，未知错误\");\n          }\n      }\n  }\n  ```\n\n#### 用户注册接口\n\n* **保证注册手机号的唯一性**\n\n  + 可以在数据库建表的时候将phone字段添加唯一约束unique\n  + 可以在用户注册的时候，根据前端传来的手机号在数据库中查找，保证唯一\n\n* **MD5 密码加密**\n\n  + 建一个工具类(将代码拷过去就能直接使用)\n\n    ```\n    public static String MD5(String data)  {\n            try {\n                java.security.MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                byte[] array = md.digest(data.getBytes(\"UTF-8\"));\n                StringBuilder sb = new StringBuilder();\n                for (byte item : array) {\n                    sb.append(Integer.toHexString((item & 0xFF) | 0x100).substring(1, 3));\n                }\n    \n                return sb.toString().toUpperCase();\n            } catch (Exception exception) {\n            }\n            return null;\n    \n    }\n    ```\n\n#### 用户登录接口\n\n+ JWT工具类开发\n\n  + pom文件添加依赖\n\n    ~~~\n    <!-- JWT相关 -->\n        <dependency>\n          <groupId>io.jsonwebtoken</groupId>\n          <artifactId>jjwt</artifactId>\n          <version>0.7.0</version>\n        </dependency>\n    ~~~\n\n  + 封装生产token方法\n\n    ~~~\n    /**\n         * 根据用户信息，生成令牌\n         * @param user\n         * @return\n         */\n        public static String geneJsonWebToken(User user){\n            String token = Jwts.builder().setSubject(SUBJECT)\n                    .claim(\"head_img\",user.getHeadImg())\n                    .claim(\"id\",user.getId())\n                    .claim(\"name\",user.getName())\n                    .setIssuedAt(new Date())\n                    .setExpiration(new Date(System.currentTimeMillis()+EXPIRE))\n                    .signWith(SignatureAlgorithm.HS256,SECRET).compact();\n            token = TOKEN_PREFIX + token;\n            return token;\n        }\n    ~~~\n\n  + 封装校验token方法\n\n    ```\n     /**\n         * 校验 token 方法\n         * @param token\n         * @return\n         */\n        public static Claims checkJWT(String token){\n          try  {\n              final Claims claims = Jwts.parser().setSigningKey(SECRET).parseClaimsJws(token.replace(TOKEN_PREFIX, \"\")).getBody();\n              return claims;\n          }catch (Exception e){\n              return null;\n          }\n        }\n    ```\n\n   + 工具类\n\n     ~~~\n     /**\n      * JWT工具类\n      * 1.生成的token，可以通过 base64 解密出明文信息\n      * 2.base64 解密出的明文，再次进行编码，秘钥会失效\n      * 3.无法作废以颁布的 token ，除非修改秘钥\n      */\n     public class JWTUtils {\n         /**\n          * 过期时间，一周\n          */\n         private static final long EXPIRE = 60000 *60 *24 *7;\n     \n         /**\n          * 加密秘钥\n          */\n         private static final String SECRET = \"yzpcode.xyz2644\";\n     \n         /**\n          * 令牌前缀\n          */\n         private static final String TOKEN_PREFIX = \"yzpcode\";\n     \n         /**\n          * subject\n          */\n         private static final String SUBJECT = \"yzpcode\";\n     \n         /**\n          * 根据用户信息，生成令牌\n          * @param user\n          * @return\n          */\n         public static String geneJsonWebToken(User user){\n             String token = Jwts.builder().setSubject(SUBJECT)\n                     .claim(\"head_img\",user.getHeadImg())\n                     .claim(\"id\",user.getId())\n                     .claim(\"name\",user.getName())\n                     .setIssuedAt(new Date())\n                     .setExpiration(new Date(System.currentTimeMillis()+EXPIRE))\n                     .signWith(SignatureAlgorithm.HS256,SECRET).compact();\n             token = TOKEN_PREFIX + token;\n             return token;\n         }\n     \n         /**\n          * 校验 token 方法\n          * @param token\n          * @return\n          */\n         public static Claims checkJWT(String token){\n           try  {\n               final Claims claims = Jwts.parser().setSigningKey(SECRET)\n               .parseClaimsJws(token.replace(TOKEN_PREFIX, \"\")).getBody();\n               return claims;\n           }catch (Exception e){\n               return null;\n           }\n         }\n     }\n     ~~~\n\n+ 登录拦截器\n\n  拦截器(``interceptor``)是对表现层(``controller``)之前和之后进行数据处理的。\n\n  实现一个拦截器需要实现``HandlerInterceptor接口``，然后重写里面的``preHandle方法``，这个方法是在进入``controller``之前，``postHandle``是对之后进行处理，在``postHanle``方法里面需要``return false``，``afterCompletion``是对整体完成之后处理（基本不使用），``interceptor``的执行顺序是链式的\n\n  ```\n  /**\n   * 登录拦截器\n   */\n  public class LoginInterceptor implements HandlerInterceptor {\n  \n      /**\n       * 进入到 controller之前的方法\n       * @param request\n       * @param response\n       * @param handler\n       * @return\n       * @throws Exception\n       */\n      @Override\n      public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n  \n          try {\n              String accessToken = request.getHeader(\"token\");\n  \n              if (accessToken == null) {\n                  accessToken = request.getParameter(\"token\");\n              }\n              if (StringUtils.isNotBlank(accessToken)) {\n                  Claims claims = JWTUtils.checkJWT(accessToken);\n                  if (claims == null) {\n                      //登录过期，重新登录\n                      sendJsonMessage(response, JsonData.buildError(\"登录过期，请重新登录\"));\n                      return false;\n                  }\n                  Integer id = (Integer) claims.get(\"id\");\n                  String name = (String) claims.get(\"name\");\n  \n                  request.setAttribute(\"user_id\", id);\n                  request.setAttribute(\"name\", name);\n                  return true;\n              }\n          }catch (Exception e){}\n  \n          sendJsonMessage(response, JsonData.buildError(\"登录过期，请重新登录\"));\n          return false;\n  \n      }\n      /**\n       * 响应 JSON 数据给前端\n       * @param response\n       * @param obj\n       */\n      public static void sendJsonMessage(HttpServletResponse response,Object obj){\n          try{\n              ObjectMapper objectMapper = new ObjectMapper();\n              response.setContentType(\"application/json; charset=utf-8\");\n              PrintWriter writer = response.getWriter();\n              writer.print(objectMapper.writeValueAsString(obj));\n              writer.close();\n              response.flushBuffer();\n          }catch (Exception e){\n              e.printStackTrace();\n          }\n      }\n  \n      @Override\n      public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n  \n      }\n  \n      @Override\n      public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n  \n      }\n  }\n  ```\n\n#### Guava缓存\n\n+ 添加依赖\n\n  ```\n  <dependency>\n  \t<groupId>com.google.guava</groupId>\n  \t<artifactId>guava</artifactId>\n  \t<version>19.0</version>\n  </dependency>\n  ```\n\n+ 工具类\n\n  ```\n  @Component\n  public class BaseCache {\n  \n      private Cache<String,Object> tenMinuteCache = CacheBuilder.newBuilder()\n              //设置缓存初始大小，需要合理设置\n              .initialCapacity(10)\n              //最大值\n              .maximumSize(100)\n              //并发数设置\n              .concurrencyLevel(5)\n              //缓存过期时间，写入后10分钟过期\n              .expireAfterWrite(600, TimeUnit.SECONDS)\n              //统计缓存命中率\n              .recordStats()\n              .build();\n  \n      private Cache<String,Object> oneHourCache = CacheBuilder.newBuilder()\n              //设置缓存初始大小，需要合理设置\n              .initialCapacity(10)\n              //最大值\n              .maximumSize(100)\n              //并发数设置\n              .concurrencyLevel(5)\n              //缓存过期时间，写入后10分钟过期\n              .expireAfterWrite(3600, TimeUnit.SECONDS)\n              //统计缓存命中率\n              .recordStats()\n              .build();\n  \n      public Cache<String, Object> getOneHourCache() {\n          return oneHourCache;\n      }\n  \n      public void setOneHourCache(Cache<String, Object> oneHourCache) {\n          this.oneHourCache = oneHourCache;\n      }\n  \n      public Cache<String, Object> getTenMinuteCache() {\n          return tenMinuteCache;\n      }\n  \n      public void setTenMinuteCache(Cache<String, Object> tenMinuteCache) {\n          this.tenMinuteCache = tenMinuteCache;\n      }\n  }\n  ```\n\n\n#### Redis\n\n+ **自定义序列化和反序列化机制配置**\n\n  ```java\n  @Configuration\n  public class RedisTemplateConfiguration {\n  \n      /**\n       * @param redisConnectionFactory\n       * @return\n       */\n      @Bean\n      public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {\n  \n          RedisTemplate<Object, Object> redisTemplate = new RedisTemplate<>();\n          redisTemplate.setConnectionFactory(redisConnectionFactory);\n          // 使用Jackson2JsonRedisSerialize 替换默认序列化\n          Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\n  \n          ObjectMapper objectMapper = new ObjectMapper();\n          objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n          jackson2JsonRedisSerializer.setObjectMapper(objectMapper);\n  \n          // 设置key和value的序列化规则\n          redisTemplate.setKeySerializer(new StringRedisSerializer());\n          redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);\n  \n          // 设置hashKey和hashValue的序列化规则\n          redisTemplate.setHashKeySerializer(new StringRedisSerializer());\n          redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);\n  \n          // 设置支持事物\n          //redisTemplate.setEnableTransactionSupport(true);\n  \n          redisTemplate.afterPropertiesSet();\n  \n          return redisTemplate;\n      }\n  \n  }\n  ```\n\n  \n\n  ","tags":["Java"]},{"title":"最大数","url":"/2023/01/01/最大数/","content":"#### 最大数\n\n+ 题目：\n\n  ![](https://picgo-1309496466.cos.ap-chongqing.myqcloud.com/pic/%E6%9C%80%E5%A4%A7%E6%95%B0.png)\n\n+ 题解：最大数就是将最大的组成放在前面，如示例2里面的``3和30比较，330和303，就是330更大，所以元素3在30之前``，将数字数组中的对应元素转为字符串数组中，然后用``compareTo()``方法进行比较，它是从头开始比较字符串对应的``AscII码``值，如果第一个字符相等，就比较后面一个，然后我们用快速排序方法``Arrays.sort()``的``lambda表达式``方式，具体的``Arrays.sort()中的lambda表达式``讲解[](https://blog.csdn.net/qq_41030039/article/details/100176410)\n\n+ 代码：\n\n  ```java\n  class MyAnswer{\n      public String largestNumber(int []nums){\n          int n = nums.length;\n          String[] array = new String[n];\n          for(int i=0;i<n;i++){\n              array[i] = String.valueOf(nums[i]);\n          }\n          //a.concat(b)方法是将两个字符串拼接在一起\n          Arrays.sort(array,(a,b)->b.concat(a).compareTo(a.concat(b)));\n          //如果第一个元素就是0；那么后面的都比零小，所以直接返回0\n          if(array[0].equals(\"0\")){\n              return \"0\";\n          }\n          StringBuilder sb = new StringBuilder();\n          for(int i=0;i<n;i++){\n              sb.append(array[i]);\n          }\n          return sb.toString();\n      }\n  }\n  ```\n\n  ","tags":["力扣刷题"]},{"title":"买卖股票的最佳时机","url":"/2022/12/28/买卖股票的最佳时机/","content":"#### 买卖股票的最佳时机||\n\n+ 题目：\n\n  ![](https://picgo-1309496466.cos.ap-chongqing.myqcloud.com/pic/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA2.png)\n\n+ 题解：\n\n  从数组的最前面开始遍历数组，利用双指针，当前面一个数字比后面一个数字小的时候，就让前面的数字进行购买，然后再从后面找一个最大的数字，把他比作卖出。更好理解的就是：如果把他比作为单调函数的话，一开始是单调递减的话，那么就当开始递增的那个点就肯定是最小的，那个点就购买，然后再递减了的那个点就是局部最大，所以那个点就卖出，这样两个点的差值就最大。\n\n  ![](https://picgo-1309496466.cos.ap-chongqing.myqcloud.com/pic/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E9%A2%98%E8%A7%A3.png)\n\n+ 代码:\n\n  ```java\n  class MyAnswer{\n       public int maxProfit(int[] prices) {\n           if(prices==null||prices.length<2){\n               return 0;\n           }\n           int sum =0, index=0,n=prices.length;\n           while(index<n){\n               //当一直递减就找到最小的值\n               while(index<n-1 && prices[index]>=prices[index+1]){\n                   index++;\n               }\n               int min = prices[index];\n               //找到递增的最大值\n               while(index<n-1 && prices[index]<=prices[index+1]){\n                   index++;\n               }\n               sum += prices[index++]-min;\n           }\n           return sum;\n       }\n  }\n  ```\n\n  ","tags":["力扣刷题"]},{"title":"多线程并发编程","url":"/2022/12/07/多线程并发编程/","content":"#### 什么是并发编程\n\n+ 串行和并行的区别：并行可以缩短整个流程的时间\n+ 并发编程的目的:从某种程度上加快程序响应的速度（耗时任务，web服务器），简化异步事件的处理，让程序充分利用计算机资源\n+ 什么时候适合使用并发编程：\n  + 任务会阻塞线程，导致之后的代码不能执行：比如一边从文件中读取，一边进行大量的计算的情况\n  + 任务执行时间过长，可以划分为分工明确的子任务：比如分段下载\n  + 任务间断性执行：日志打印\n  + 任务本身需要协作执行：比如生产者消费者问题\n\n#### 并发编程挑战频繁的上下文切换\n\n+ 上下文的频繁切换，会带来一定的性能开销\n+ 如何减少上下文切换的开销？\n  + 无锁并发编程\n    + 无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的id按照hash算法取模分段，不同的线程处理不同分段的数据\n  + CAS\n    + Java的Atomic包使用的CAS算法来更新数据，而不需要加锁\n  + 使用最少的线程\n    + 避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态\n  + 协程（go语言使用的多，就Java很少使用）\n\n#### 并发编程挑战死锁\n\n+  在cmd控制台输入jconsole可以查看是否出现死锁\n\n#### 并发编程挑战线程安全\n\n+ ~~~java\n  public class UnSafeThread{\n      private static int num=0;\n      private static CountDownLatch cdl=new CountDownLatch(10);\n      \n      \n      public static void inCreate(){\n         num++;\n      }\n      public static void main(String []args){\n      for(int i=0;i<10;i++){\n          new Thread(()->{\n            for(int j=0;j<100;j++){\n            inCreate();\n            Thread.sleep(10)://会抛异常需要捕获\n            }\n            //每个线程执行完成之后，调用countdownlatch\n            cdl.counyDown();\n  }).start();\n      }\n      while(true){\n        if(cdl.getCount()==0){\n           System.out.println(num);\n           break;\n        }\n      }\n      }\n  \n  }\n  ~~~\n\n\n\n#### 并发编程挑战资源限制\n\n+ 硬件资源\n  + 带宽的上传和下载熟读，硬盘的读写速度和CPU的处理速度\n+ 软件资源\n  + 数据库连接 500个连接，1000个线程查询，并不会因此加快，socket（最大打开数）\n\n#### 线程的基础知识\n\n+ 进程和线程的区别\n\n  + 进程：是系统进行分配和管理资源的基本单位\n  + 线程：进程的一个执行单元，是进程内调度的实体，是CPU调度和分配和分派的基本单位，是比进程更小的独立运行的基本单位。线程也被称为轻量级进程，线程是程序执行的最小单位\n  + 一个程序至少一个进程，一个进程至少一个线程\n  + 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段，堆栈段和数据段，这种操作十分昂贵\n  + 而线程是共享进程中的数据的 ，使用相同的地址空间，因此cpu切换一个进程的花费远比进程要小很多 ，同时创建一个线程的开销也比进程要小很多\n  + 线程之间的通信更方便，同一个进程下的先后才能共享全局变量，静态变量等数据，而进程之间的通信需要以通信的方式进行\n  + 如何处理好同步与互斥是编写多线程程序的难点\n  + 多进程程序更健壮，进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其他的进程产生影响，而线程只是进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间，没有独立的地址空间，所以可能一个线程出现问题，进而导致整个程序出现问题\n\n+ 线程的状态及其相互转换\n\n  + 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法\n\n  + 运行(runnable)：chuy7u可运行状态的线程在JVM中执行，但他可能正在等待来自操作系统的其他资源，例如处理器\n\n  + 阻塞(blocked)：线程阻塞与synchronized锁，等待获取synchronized锁的状态\n\n  + 等待(waiting)：Obiect.wait(),join(),LockSupport.park(),进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）\n\n  + 超时等待(time_waiting):\n\n    Object.wait(long),Thread.join(),LockSupport.parkNanos(),LockSupport.parkUntil，该状态不同于waiting，他可以在指定的时间内自行返回\n\n  + 终止(terminated)：表示该线程已经执行完毕\n\n  + 他们之间的相互转换\n\n    ![](https://picgo-1309496466.cos.ap-chongqing.myqcloud.com/pic/image-20220913094152576.png)\n\n+ 创建线程上\n\n  + 第一种是直接继承Thread，并重写父类的run方法\n\n    ```java\n    public class MyThread extends Thread{\n       @Override//重写run方法\n       public void run(){\n          System.out.println(Thread.currentThread.getName());\n       }\n       \n       public static void main(String []args){\n         MyThread myThread=new MyThread();\n         mythread.setName(\"余贞佩真帅\");\n         myThread.start();\n         }\n    }\n    ```\n\n  + ()第二种直接实现Runable接口，并实现run方法\n\n    ```\n    public class MyRunable implements Runable{\n       @Override//重写run方法\n       public void run(){\n         System.out.println(Thread.currentThread().getName());\n       }\n       \n       public static void main(String []args){\n          Thread thread=new Thread(new MyRunable());\n          thread.setName(\"余贞佩是帅哥\");\n          thread.start();\n          \n          \n          //不使用thread.start而直接使用run的话,不会启动线程，只会启动原本的线程，在实际开发中需要用thread.start()\n          thread.run();\n       }\n       \n    }\n    ```\n\n  + 实际开发中，选第二种，因为Java只支持单继承，支持多接口，还可以增加程序的健壮性，代码可以共享，代码和数据相对独立\n\n+ 创建线程下\n\n  + 使用匿名内部类的方式（也是runnable）\n\n    ```\n    public class MyThread{\n       public static void main(String []args){\n       Thread thread=new Thread(new Runnable(){\n         @Override\n          public void run(){\n          System.out.println(\"余贞佩真帅\");\n       }\n       );\n          \n    }\n       }\n    }\n    ```\n\n   + 使用Lambda\n\n     ```\n     public class Lambda{\n         public static void main(String []args){\n         new Thread(()->{\n            System.out.println(\"余贞佩真帅\");\n         }).start();\n         }\n     }\n     ```\n\n    + 使用线程池的方法ExecutorService\n\n      ```\n      public class ThreadPool{\n         public static void main(String []args){\n         ExecutorService executorSevice=Executor.newSingleThreadExecutor();\n         executorService.execute(()->{\n         System.out.println(\"余贞佩真帅\");\n       \n         });\n           }\n      }\n      ```\n\n+ 线程的挂起和恢复\n\n  + 什么是挂起线程\n\n    + 线程的挂起操作实质上就是使线程进入“非可执行”状态，在这个状态下cpu不会分给线程时间片，进入这个状态可以用来暂停一个线程的运行，在线程挂起后，可以通过重新唤醒线程来恢复运行\n\n  + 为什么要挂起线程\n\n    + cpu分配的时间片非常短，同时也非常珍贵，避免资源的浪费\n\n  + 如何挂起线程\n\n    + thread.suspend();//挂起   不会释放线程所占用的资源，如果使用该方法将某个线程挂起，则可能使其他等待资源的线程死锁\n\n    + thread.resume();//唤醒       脱离了suspend就无法使用，无法单独使用。这两个方法不用了\n\n    + 可以使用的方法\n\n      + wait();//暂停执行，放弃已获得的锁，进入等待状态\n\n      + notify();//随机唤醒一个在等待锁的进程\n\n      + notifyAll();//唤醒所有在等待锁的进程，自行抢占cpu资源\n\n      + ```\n        public class WaitDemo{\n             private  static Object waObject=new Object();\n             @Override\n             public void run(){\n             //特有资源\n             synchronized(waObject){\n              System.out.println(\"yuzhenpe\"+\"余贞佩\");\n              waObject.wait();//这里需要捕获异常\n             }\n             System.out.println(\"太帅了\");\n        }\n           public static void main(String []args){\n           Thread thread=new Thread(new WaitDemo(),name\"线程名字\");\n           thread.start();\n           Thread.sleep(1000L)//休眠一秒钟\n           synchronized(waObject){\n           waObject.notify();\n        }\n           }\n        }\n        \n        注意：在使用的时候需要注意两个都需要持有锁，并且都需要是锁住的是相同的对象\n        ```\n\n  + 什么时候适合使用挂起线程\n\n    我等的船还不来（等待某些未就绪的资源，让出时间片给其他的线程，直到notify唤醒）\n\n+ 线程的中断操作\n\n  + stop();//已经废弃的方法，不要使用。因为一调用，线程就立刻停止，此时有可能引发相应的线性安全性问题\n\n  + interrupt();方法\n\n    ```\n    public class InterruptDemo implements  Runnable{\n        @Override\n        public void run(){\n          while(!Thread.currentThread().isInterrupt()){//判断是否被interrupt方法标记了中断线程\n              System.out.println(\"余贞佩真帅\");\n          }\n        }\n        \n        public static void main(String []args){\n           Thread thread=new Thread(new InterruptDemo());\n           thread.start();\n           Thread.sleep(3000L);\n           thread.interrupt();//调用这个方法会给线程标记中断线程的标记\n        }\n    \n    }\n    ```\n\n  + 通过volatile来定义变量来实现\n\n    ```\n    public class MyInterruptDemo imlements Runnable{\n        private static volatile boolean flag=ture;//这里一定需要加volatile关键字\n        @Override\n        public void run(){\n        while(flag){\n          System.out.println(\"余贞佩真帅\");\n        }\n        }\n        public static void main(String []args){\n          Thread thread=new Thread(new MyInterruptDemo());\n          thread.start();\n          Thread.sleep(1000L);\n          flag=false;//通过修改volatile修饰的变量来控制退出循环中断线程\n        }\n        \n    }\n    ```\n\n+ 线程的优先级\n\n  + 线程的优先级会告诉程序该线程的重要程度。如果大量线程都被堵塞，都在等候运行，那么程序会尽可能的优先运行优先级高的线程。不代表优先级低的线程不会被运行，只是被运行的机会比较少\n\n  + 设置线程的优先级\n\n    ```\n    public class PriorityDemo{\n         \n         public static void main(String []args){\n           \n           Thread thread1=new Thread(()->{\n               System.out.println(Thread.currentThread().getName()+\"余贞佩真帅\");\n           },\"线程1\");\n           Thread thread2=new Thread(()->{\n               System.out.println(Thread.currentThread().getName()+\"余贞佩真帅\");\n           },\"线程2\");\n           thread1.setPriority(MIN);//设置为1到10之间的整数，Priority提供了1,5,10三种（建议）\n           thread2.setPrioity(MAX);\n           thread1.start();\n           thread2.start();\n         }\n    }\n    ```\n\n  + 线程优先级可以设置为1-10的任意数值，Thread类定义了三个数值表示线程优先级，MIN_PRIORity(1);NORM_PRIORITY(5);MAX_PRIORITY(10);一般情况推荐使用这三种，不要自行设置数值\n\n  + 不同的平台对线程优先级的支持不同\n\n    + 编程的时候不要过度依赖线程优先级，如果程序的运行是否正确取决于你设置的优先级是否按所设置的优先级运行，那这样的程序不正确\n\n  + 任务是快速处理就设置为优先级高\n\n  + 任务是慢慢处理就设置为优先级低（但是得保证不影响程序运行）\n\n+ 守护线程\n\n  + 线程分类：用户线程，守护线程\n\n  + 守护线程\n\n    + 任何一个守护线程都是用户线程的守护者，只要有用户线程活着，守护线程就活着。在JVM实例中最后一个非守护线程结束时，也随JVM一起退出\n    + 作用：JVM垃圾清理线程\n\n  + 在开发中少使用守护线程，因为其不可控，容易在运行到一半的时候随着用户线程的消失而消失，如果一定要使用守护线程，也不要在守护线程进行读写计算等逻辑\n\n  + 在Java中设置守护线程\n\n    ```\n    public static void main(String []args){\n          Thread thread=new Thread(new Yzp());\n          thread.setDaemo(ture);//系统默认false\n          thread.start();\n          //注意，设置为守护线程一定需要在thread.start()之前，在之后不会被设置为守护线程\n    }\n    ```\n\n\n#### 线程安全\n\n+ 线程安全性问题\n\n  + 什么是线程安全性\n    + 当多个线程访问某个类，不管运行环境如何调度或线程如何交替执行，并且在主调代码中不需要任何额外的同步或者协同，这个 类都能做出正确的行为，那么这个类是线程安全的\n  + 什么是线程不安全\n    + 多线程并发访问的时候，得不到正确的结果\n\n+ 从字节码剖析线程不安全操作\n\n  + 例子：num++不是原子性操作，被拆分为多个步骤，在多线程并发执行的时候，因为cpu的调度，多线程快速切换，有可能多个线程在同一个时刻读取了同一个num的值，然后对相同的num值进行++，得不到正确的结果，导致线程安全性问题\n\n+ 原子性操作\n\n  + 什么是原子性操作\n\n    一个操作或多个操作在执行的过程中不会被任何因素阻断，要么都不执行\n\n  + 如何把非原子性操作变为原子性操作\n\n    + volatile关键字仅仅保证可见性，并不能保证原子性\n\n    + synchronized关键字，可以使操作具有原子性\n\n + synchronized关键字\n\n   + 内置锁\n\n     每一个Java对象，都可以用做一个实现同步的锁，这些锁称为内置锁。线程进入同步代码块或者方法的时候会自动获得该锁，在退出同步代码块或者方法的时候会释放该锁\n\n     获得内置锁的唯一途径是进入这个锁所保护的同步代码块或方法\n\n   + 互斥锁\n\n     + 内置锁是一个互斥锁，这就意味着最多只有一个线程可以获得这个锁，当线程a尝试获得线程b所持有的锁的时候，线程a会进入堵塞或者等待状态，直到线程b释放这个锁\n     + 如果线程b一直不释放锁，那么线程a就会一直等待或者堵塞\n\n   + 修饰普通方法：锁住的是类的实例`public synchronized void test()`\n\n   + 修饰静态方法：锁住的是整个类（最好不要用）`public static synchronized`staticTest()\n\n   + 修饰代码块：锁住的是一个对象。锁住的是synchronized括号后面的那个对象\n\n     + ```\n       public void yzp(){\n          synchronized(对象){\n          \n          }\n       }\n       ```\n\n + volatile关键字\n\n   + 能且仅能修饰变量\n   + 保证变量的可见性，但是不能保证原子性\n   + 禁止指令重排序\n   + 比如：A,B两个线程同时读取被volatile修饰的对象，A线程的读取过后修改了变量的值，修改的值对于B线程来说是可见的\n   + 使用场景\n     + 作为线程的开关\n     + 单例，修饰对象的实例，禁止指令重排序\n\n + 单例与线程安全\n\n   + 饿汉式（本身线程安全）不需要加锁\n\n     在类加载的时候就已经实例化，不管用不用的到。如果该类占内存大，且后面也用不到，就白白浪费了资源\n\n     + 在idea有一个Singleton可以帮我们创建\n\n   + 懒汉式（最简单的写法是非线程安全的）\n\n     在需要的时候在进行实例化\n\n     ```\n     public class LazySingleton{\n           praivate static volatile LazySingle=null;//在这里需要volatile关键字来禁止指令重排序\n           private LazySingle(){//私有化\n     }\n          public static LazySingleton getInstance(){\n          //判断实例化是否为空，为空则实例化对象，否者直接返回\n          if(null==lazySingle){\n            Thread.sleep();//这里需要抛出异常\n            synchronized(LazySingle.class){\n              if(null==lazySingle){\n               lazysinglr=new LazySingle();\n     }\n            }\n          }\n          return lazySingle;\n          \n          }\n     }\n     这样是线程安全的\n     ```\n\n + 如何避免线程安全性问题\n\n   + 产生线程安全性的原因\n\n     + 多线程环境\n     + 多个线程操作同一个共享资源\n     + 对该共享资进行了非原子性操作\n\n   + 如何避免\n\n     打破三个成因其中一个\n\n     + 将多线程变为单线程（必要的代码，加锁访问）\n     + 不共享资源（ThreadLocal,不共享，或者将操作变为无状态，将变量变为不可变变量（final））\n     + 将非原子性操作变为原子性操作（加锁，使用jdk自带的原子性操作的类，juc提供的相应的并发工具类）\n\n#### 锁\n\n+ 锁的分类\n\n  <img src=\"https://picgo-1309496466.cos.ap-chongqing.myqcloud.com/pic/image-20220915162626728.png\" style=\"zoom: 50%;\" />\n\n  <img src=\"https://picgo-1309496466.cos.ap-chongqing.myqcloud.com/pic/image-20220915162807317.png\" style=\"zoom:50%;\" />\n\n+ 深入理解Lock接口\n\n  + Lock的使用\n\n    ```\n    private static Lock lock=new ReeentrantLock();\n    public static void inCreate(){\n       lock.lock();//在需要加锁的方法内加锁\n       num++;\n       lock.unlock();//需要手动的解锁\n    }\n    ```\n\n  + lock和synchronized的区别\n\n    + lock需要手动的加锁和解锁，synchronized则是托管给jvm去实现\n    + synchronized的机制是悲观锁，每个线程都是独占锁，独占锁意味着其他的锁只能依靠堵塞来等待释放锁\n    + lock是乐观锁，实现CAS操作\n    + 而synchronized现在与lock的性能差不多\n\n+ 实现自己的锁（具有重入的功能）\n\n  + ```\n    public class MyLock implements Lock{\n        \n        private boolean isHoldLock=false;\n        private Thread holdLockThread=null;\n        private int reentryCount=0;\n    \n        //重写Lock类的方法\n        //在同一时刻有且只有一个线程能获的锁，其他的线程需要等待这个线程释放锁后才能获得锁\n        @Override\n        public synchronized void lock(){//需要用到wait和notify方法所以需要在方法上面上锁\n            if(isHoldLock&&holdLockThread!=Thread.currentThread()){\n                  wait();//这里需要抛出异常\n            }\n            holdLockThread=Thread.currentThread();\n            isHoldLock=true;  \n        }\n        @Override\n        public synchronized void unlock(){\n        //判断当前线程是否持有锁，如果是，重入数就减一，不是就不做处理\n           if(Thread.currentThread==holdLockThread){\n               reentryCount--;\n              if(reentryCount==0){\n               notify();\n               isHoldLock=false;\n              }\n          }\n        }\n    \n    }\n    ```\n\n+ AbstractQueuedSynchronizer浅析\n\n+ ReentrantLock源码（new的时候带参数TRUE就是公平锁，不带参就是非公平锁）\n\n+ ReentrantLock公平锁和非公平锁的区别\n\n  + 公平锁遵守排队规则，比如在公共厕所上厕锁，只要前面的在排队，那么刚进来的就会老老实实的排队\n  + 非公平锁有点像流氓，只要当前有空的坑位，他就会直接霸占，不管后面排队的人。只要有机会就会抢占资源\n\n+ 非公平锁的弊端\n\n  + 可能导致后面等待的线程等不到相应的cpu资源从而引起线程饥饿\n\n+ 掌控线程的执行顺序之多线程Debug\n\n  + 在使用ReentrantLock类的时候释放锁的操作需要放在异常finally里面\n  + \n\n","tags":["并发编程"],"categories":["Java"]},{"title":"HTML和CSS基础","url":"/2022/12/06/HTML和CSS基础/","content":"## HTML\n\n##### 基础知识\n\n* 常见的几个标签：\n\n  ```\n  <meta>标签是放在<head>下的,没有结束标签为自结束标签\n  <a herf>标签是放在<body>下的，定义一个超链接，用于跳转网站\n  &nbsp;  这个是在网页中加空格，要添加多少空格就写多少次\n  <link>标签是放在<title>下的，用于链接外部的样式表\n  <hr>标签是放在<body>下的，加一条横线区分上半段和下半段\n  <img>标签是放在<body>下的，在网页中添加图片，其中src后面是放图片的地址，alt后面是图片的标签\n  <input>标签是放在<body>标签下的，创建一个输入框\n  ```\n\n* 注释\n\n  + 当代码复杂度大时，便于解释说明代码的含义\n  + 注释暂时用不到的代码片段\n  + 注释不能嵌套，否则网页中会渲染出-->\n\n* 语义化标签\n\n  ```\n  <title>网页标签是网站和标签的名字\n  <h1>~<h6>：网页内容的标题(最好只使用一个h1)一般使用h1~h6\n  <p>标签是换行的操作，相当于Word里面的回车换行\n  <strong>强调加粗度字体\n  下面几种很少用到：\n  头部元素：header\n  导航元素：nav\n  主要内容：main\n  ```\n\n  + 优化代码结构：在页面没有css的情况下，也能够呈现出很好的内容结构\n  + 有利于SEO：标签确定关键字的权重，因此可以增加搜索相关权重，使网站搜索结果中的排列顺序\n\n##### 具体知识\n\n* **a标签的用法**\n\n  ```\n  跳转：<a href=\"网站地址\">网站名字</a>\n  锚点：<a href=\"#xxx\">网页中的点击名字</a>（用于点击网页跳转）\n  点击网页跳转并打开另一个浏览器界面：<a href=\"网站地址\" target=\"blank\">网页中的点击名</a>\n  ```\n\n* target属性\n\n  + blank：打开新的浏览器标签\n\n* 路径\n\n  根据资源的类型判断，一般站外资源用绝对路径，站内资源用相对路径\n\n  + 绝对路径\n\n    `https://xdclass.net`\n\n  + 相对路径\n\n    ```\n    ./ 代表当前目录\n    ../ 代表的上一级目录\n    内部的资源也可以用绝对路径，即文件的存储地址\n    ```\n\n* **img标签**\n\n  ```\n  <img src=\"图片地址\" alt=\"图片加载失败或加载时的文字\" title=\"网页靠近图片时显示的名字\">\n  ```\n\n  + 图片的来源\n\n    + 本地图片：稳定\n\n    + 线上图片：图片容易丢失\n\n    + Base64图片\n\n      优点:小图片占用内存少，不请求服务器，降低服务器资源与访问\n\n      缺点：大图片增加了数据库服务器的压力\n\n  + 点击图片跳转\n\n    + 通过嵌套a标签 \n\n      `<a href=\"网站地址\"> <img>标签  </a>`\n\n* **表格table标签**\n\n  + 表的基本结构\n\n    由一行或者多行的单元格数据组成\n\n    | 姓名 | 性别 | 年龄 |\n    | ---- | ---- | ---- |\n    | 张三 | 男   | 18   |\n    | 李四 | 女   | 18   |\n\n  + 在HTML中表示\n\n    + table：HTML表格\n\n    + tr：元素定义表格行\n\n    + th：数据中的表格头单元格（相当于有多少列）\n\n    + td：表示单元格\n\n    ```\n    <table> border=\"1\" cellspacing=\"10px\" cellpandding=\"10px\"\n       <tr>\n          <th>姓名</th>\n          <th>性别</th>\n          <th>年龄</th>\n       </tr>\n       <tr>\n          <th>张三</th>\n          <th>男</th>\n          <th>18</th>\n       </tr>\n       <tr>\n          <th>李四</th>\n          <th>女</th>\n          <th>18</th>\n       </tr>\n    </table>\n    ```\n\n   + table元素李常用的属性\n\n     + border（边框）\n     + cellspacing（规定单元格之间的空白）\n     + cellpadding（规定单元格沿与其内容之间的空白）\n     + colspan（用于合并列）\n     + rowspan（用于合并行）\n\n* **列表ul、ol标签**\n\n  + 有序列表 \n\n    ```\n    <ol>\n      <li></li>\n    </ol>\n    ```\n\n   + 无序列表(使用的最多)\n\n     ```\n     <ul>\n       <li></li>\n     </ul>\n     ```\n\n    + 定义列表\n\n      ~~~\n      <dl>\n        <dt>人</dt>\n        <dd>一种哺乳动物</dd>\n      </dl>\n      ~~~\n\n* **表单form标签**\n\n  使用场景需要提交一些信息到服务端的时候（前后端联调过程中）\n\n  + 核心元素input（核心元素）`<input type=\"text\">`表示一个基本的文本框\n\n  + label（提高交互体验的）\n\n    ```\n    第一种\n    <label>\n       <input type=\"checkbox\">同意\n    </label>\n    第二种\n    <label for=\"\">同意</label>\n    <input type=\"checkbox\" id=\"isagree\">\n    ```\n\n  + select（下拉框）\n\n    ```\n    <select>\n       <option value=\"1\">男</option>\n       <option value=\"2\">女</option>\n    </select>\n    ```\n\n    \n\n  + textarea（文本域）\n\n  + button（按钮）\n\n    ```\n    <button type=\"submit\">注册</button> 点击网页的这个按钮就讲这个传给form 后面的action给后台\n    ```\n\n    \n\n  + form（表氮元素，提交每个表单项内容）\n\n* **区块和行内标签**\n\n  + div元素(用的很多)\n\n    + div元素是块级元素，他可以用于组合其他HTML元素的容器\n    + div元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行\n    + 如果与CSS一同使用，div元素可以用于对打的内容块设置样式属性\n    + div元素的另一个藏剑的用途是文档布局\n\n  + span元素（用的很多）\n\n    + span元素是行内元素，可以作为文本的容器\n    + span元素也没有特定的含义\n    + 当与CSS一同使用时，span元素可用于为部分文本设置样式属性\n\n  + 块级元素\n\n    + 块级元素在浏览器显示时，通常会以新行来开始（和结束）\n\n      `<h1><p><ul><table><div>`\n\n  + 行内元素\n\n    + 行内元素在显示时通常不会以新行开始\n\n      `<b><td><a><img><span>`\n\n## CSS\n\n##### CSS基础知识\n\n* **基础规则**\n  + 选择器：告诉浏览器要设置样式的html元素\n  + 声明块：用于设置样式\n  + 层叠样式表（相同的设计最后一个会覆盖前面的设计）\n  + Viewport：将网页的视口设置为完美视口，开发移动端页面时一定要加上\n* **CSS的几种推荐写法**\n  + 写法\n    + 內部样式表：写在元素的style标签里面的\n    + 内联样式表：写在div 里的styles属性里面的\n    + 外部样式表：link标签将css资源引入\n  + 为什么采用外部样式表\n    + 解决页面当中样式重复的问题\n    + 代码分离，利于代码维护和阅读\n    + 浏览器会缓存起来，提高页面相应速度变快了\n\n##### CSS核心技术\n\n* 选择器的选择\n\n  + 元素（标签）选择器\n\n    `组合选择器：h1,p{color:red;}`当属性相同时可以节省很多代码行\n\n  + 类选择器\n\n    + 结合标签选择器\n\n      ```h1.xiaodi{color:red;}\n      在div里声明class <div class=\"yzp\">余贞佩</div>\n      则可以在style下用.yzp{}编辑属性\n      <p class=\"yzp\">余贞佩</p>\n      可以用p.yzp{}进行编辑\n      ```\n\n    + 多类选择器\n\n      ```class=\"yzp background\"\n      <div class=\"yzp background\">余贞佩</div>\n      可在style下.class{}和.background{}进行编辑如果使用.background.yzp{}的话在编辑内容里面必须包含两个\n      ```\n\n  + id选择器\n\n    ```\n    声明：#important{}\n    属性：id=\"important\"\n    \n    注意：一个id选择器的属性值在html文档中只能出现一次，避免写js获取id时出现混淆\n    ```\n\n   + 通配符选择器\n\n     将所有的都修改但优先级很低\n\n   + 派生选择器\n\n     + 后代选择器\n\n       ```\n       h1 p{color:red;}\n       <h1>\n          <p>余贞佩</h>\n       </h1>只要是h1下p中相同的标签都可以修改\n       ```\n\n     + 子元素选择器\n\n       ```\n       h1>p{}表示修改h1中的p标签而不修改h2\n       <h1>\n          <p>余贞佩</p>\n       </h1>\n       <h2>\n          <p>余贞佩</p>\n       </h2>\n       ```\n\n      + 相邻选择器(兄弟选择器)\n\n        `h1+p{background-color:pink;}`\n\n        必须要有相同的父级才能修改，但是是从第二个开始\n\n* 特殊的选择器\n\n  1. 伪类选择器\n\n  + 不改变任何DOM内容。只是插入了一些修饰类的元素\n    ![](C:\\Users\\阿余\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220803180725240.png)\n\n2. 伪元素选择器\n\n```\n::first-letter  //第一个元素\n::first-line  //第一行 只能用于块级元素\n::selection  //选中\n::before   //在开始位置\n::after  //在结束位置\n```\n\n##### CSS基础概念之盒子模型\n\n1. 盒子的内边距（padding）\n\n   ![](C:\\Users\\阿余\\AppData\\Roaming\\Typora\\typora-user-images\\盒子的内边距.png)\n\n2. 盒子的边框（border）（宽度，样式，颜色）\n\n   ![](C:\\Users\\阿余\\AppData\\Roaming\\Typora\\typora-user-images\\盒子的边框.png)\n\n3. 盒子的外边距（margin）\n\n   ![](C:\\Users\\阿余\\AppData\\Roaming\\Typora\\typora-user-images\\盒子的外边距.png)\n\n   * 盒子怪异模型 \n\n     + W3C标准盒子模型（标准盒模型）变大\n\n       `boxWitdth=contentWidth`\n\n     + IE标准盒子模型（怪异盒模型）图片不改变时使用，外边框不改变\n\n       `box-sizing:，border-box`//声明\n\n       `boxWidth=contentWidth+border+padding`\n\n   * 外边距折叠\n\n     + 上下两个兄弟盒子的margin都为正则取大，都为负则取小，一正一负两者相加\n\n     + 父子元素盒子的margin（假设没有内边距或边框那外边距分隔开），也会合并；只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对之间的外边距不会合并\n\n       ```\n       解决父子边距合并：\n       父元素{\n        overflow:auto;\n       }\n       父元素::before{\n          display:table;\n          content:\"\";\n       }\n       ```\n\n* **CSS的常用属性 **\n\n  + 盒子的位置和大小\n\n    ```\n    宽度 width: 长度|百分比|auto\n    高度 height\n    边界 margin padding 上右下左|上下左右\n    ```\n\n   + 布局\n\n     ```\n     浮动： float\n     定位：position\n     弹性布局：flex\n     盒子内容超出部分：overflow:hidden|scroll|auto   隐藏|滑动|滑动\n     ```\n\n    + 外观、风格\n\n      ```\n      background-image: url('图片地址');\n      background-repeat: no-repeat\n      background-size:100%|50%\n      background-position:center|bottom\n      background-color: red;\n      background: red url('') no-repeat center;\n      background-size:100%;\n      ```\n\n     + 文字属性\n\n       ```\n       font-size  字体大小\n       font-weight  是否加粗\n       font-style  是不是斜体\n       font-family  字体是什么\n       ```\n\n* **CSS的层叠与选择器优先级**\n\n  + CSS全称：层叠样式表表（Cascading Style Sheets）\n\n  + 层叠是一个基本特征\n\n    一个css属性被多次声明的时候，会根据优先级或者声明顺序来计算采用哪个样式\n\n  + 优先级怎么计算\n\n    + 通配符选择器1：*\n\n    + 标签选择器2：div  span  p  li\n\n    + 类选择器3： class\n\n    + ID选择器4： ID\n\n    + 行内样式5  <div style=\"color:pink\">内容</div>>是直接在标签里\n\n    + ！impoant6（尽量不要再公用代码里使用）\n\n      注意：1是最低级往下升高\n\n+ **CSS常见的继承属性**\n\n  + 什么是继承\n\n    + 继承了父元素的某些特征\n    + 优点：继承可以简化代码，便于维护\n\n  + 默认设置继承的属性\n    文字属性，文本缩进，对齐，行高\n\n    ```\n    文本缩进 text-indent:50px(为正表示向右，为负向左移)\n    对齐  text-align: right(向右对齐)\n    行高 line-height:50px;\n    ```\n\n+ **CSS布局定位**\n\n  + 前置知识\n\n    + 正常元素的布局\n      1. 默认，一个块级元素的内容宽度就是其父元素的100%，它的高度与其内容高度一致\n      2. 行内元素他的高度和宽度都是根据内容决定的（无法设置行内元素的宽高）\n         + 可设置display属性将行内元素设置为块级元素，定义元素类型（Css3定义布局）\n    + 元素之间如何相互影响\n      + 正常的文档布局流\n        + 每个块级元素会在上一个元素下面另起一行\n        + 行内元素不会另起一行\n\n  + **CSS中float布局**（实现左右布局）\n\n    + float布局\n\n      ```\n      float:none;  //默认值，元素不浮动\n      float:left;  //元素向左浮动\n      float:rght;   //元素向有浮动\n      ```\n\n    + 特点\n\n      + 浮动元素会脱离文档流，不再占用文档流空间\n      + 浮动元素彼此之间是从左往右排列，宽度超过一行自动换行\n      + 在浮动元素前面元素不浮动时，浮动无法上移\n      + 块级元素和行内元素浮动之后都变成行内块级元素\n      + 浮动元素不会盖住文字，可以设置文字环绕效果\n\n    + 清除浮动\n\n      ```\n      在伪元素里设置\n      .box::after{\n      clear:both;\n      content='';\n      display:block;\n      }\n      ```\n\n  + **CSS中flex布局**（弹性布局）\n\n    + 父元素容器的属性\n\n    ```\n    1.父级设置为flex布局以后，子元素的float、clear和vertical-algin属性将失效\n    display：flex；\n    2.决定主轴的方向（即项目的排列方向）\n    flex-direction：row|row-reverse|column|column-reverse（水平方向|相反|垂直方向|相反）\n    3.是否换行\n    flex-wrap：nowrap|wrap|wrap——reverse（不换行|换行|颠倒换行）\n    4.定义水平方向对齐（用的很多）\n    justify-content：flex-end|center|space-between|space—around（从主轴右边开始|居中放在中间|两边占完，且中间居中|左右有距离边框，其余子元素的间距是两边元素距离边框距离的两倍）\n    5.定义垂直方向对齐\n    align—items：flex-end|center|baseline|stretch；（从反方向开始|居中|需要在子元素中添加line—height|需要把子元素中的height去掉，即去掉高度占满竖直方向）\n    6.定义多个轴线（多行、多列）对齐方式\n    align-content:flex-start|flex-end|center|space-between|space-around|stretch;(从上开始|从下往上|居中|)\n    ```\n\n    + 子元素容器属性\n\n      ```\n      1.定义子元素的排列顺序，默认为0\n      order：-10|-1|0|1|10;(越小越靠前，越大越靠后，没设置则默认为零)\n      2.定义子元素的放大比例，默认为0\n      flex-grow:0|1|2|3;(当设置为0时，若容器没满则不占据剩余的容器空间，若设置为1，则会把空间占满)\n      3.定义子元素的缩小比例，默认为1（则会被缩小）\n      flex-shrink:0|1;\n      4.定义在分配多余空间之前，项目占据的主轴空间（设置宽度）\n      flex-basis:<length>|auto;\n      5.flex-grow,flex-shrink和flex-basis的简写(推荐)\n      flex:0   1  auto;\n      兼容性\n      需要浏览器ie9以上\n      ```\n\n  + 怎么选择float和flex\n\n    + 推荐使用flex布局\n      1. flex布局易用，布局全面\n      2. float的创建初衷只是为了达到文字环绕的效果，另外需要清除浮动\n      3. 现在几乎所有的公式参评使用场景都在浏览器IE9以上\n\n+ **CSS中的position定位**\n\n  + 是为了布局引入的属性\n\n  + position常用的几个值\n\n    ```\n    position: static （静态定位） 父元素（默认值）\n    position: relative （相对定位） 父元素\n    position: absolute （绝对定位） 父元素（会寻找父级的relative）\n    \n    \n    position: fixed（固定定位） 父元素（固定在页面位置不动）\n    position: sticky （粘性定位） 父元素（当下滑快到下面时会在顶部不会消失）\n    \n    ```\n\n   + 相关属性\n\n     `z-index  //使用场景：当定位的盒子重叠在一起（即谁优先展示）`\n\n+ **CSS三栏布局如何实现**\n\n  + 问题：高度固定，左右两侧的盒子宽度为200px，中间自适应\n  + 解决方法\n    + float（中间的放在最下面）\n    + position（absolute，左右为零，中间放在下面）\n    + flex（中间的flex ： 1;）（最方便）\n\n+ **CSS实现水平垂直居中**\n\n  + 行内块元素（在span中display:inline-block）\n\n    ```\n    1.line-height:为行内块的height\n      text-align: center\n    2.display:flex;常用\n    justify-content:center\n    align-items:center\n    ```\n\n   + 块级元素\n\n     ```\n     1.position+margin(自身的子元素的-一半)清楚子元素的宽高\n     2.position+transform（transform:translate(--50%,-50%)）不清楚子元素的宽高\n     3.flex\n     4.table-cell兼容性差\n     ```\n\n+ **CSS高级知识点BFC**\n\n  + 定义\n    + 块格式化上下文：是web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域\n    + 即：形成了一块封闭的区域，能检测到区域内脱离文档流的元素\n  + 特点\n    + CSS中隐含的属性，开启后不会被浮动的元素覆盖\n    + BFC元素可以包含浮动元素\n    + BFC元素的子元素和父元素外边距不重叠\n  + 开启（都会有副作用）\n    + 设置元素浮动float：left\n    + 设置为行内块元元素display：inline-block\n    + overflow：hidden（推荐）\n  + 作用\n    + 清除浮动带来的影响\n    + 解决边距塌陷问题（外边距折叠也只会发生在属于同一BFC的块级元素之间）\n\n+ **CSS边框**\n\n  + 圆角\n\n    `border-radius:10px 10px 10px 10px左上 右上 右下 左下（即顺时针）`\n\n  + 盒阴影\n\n    `box-shadow：10px 10px 10px 颜色（左右平移|上下平移|阴影程度|阴影颜色）`\n\n  + 边界图片\n\n    `border-image`\n\n+ **CSS渐变**\n\n  + 基本语法\n\n    ```\n    1.background-image: linear-gradient(颜色，颜色)从上到下渐变（默认）\n    2.background-image: linear-gradient(to right,颜色，颜色)从左到右渐变\n    3.background-image: linear-gradient(to bottom right，颜色，颜色)对角线渐变\n    ```\n\n  + 角度变化也是，180是从上往下，90是左往右，0是下往上\n\n  + 多个颜色同样按上面的\n\n  + 透明度（用的最多）\n\n    `background-image: linear-gradient(rgba(255,0,0,0),rgba(255,0,0,1))`rgba()里面的前三个值时颜色的值，最后一个的值1是不透明，0是透明，最后一个值表示透明度\n\n  + 重复\n\n    `background-image: repeating-linear-gradient(red,yellow 10%,green 20%)`1除以10%表示重复十个，1除以20%表示重复五个\n\n+ **CSS文本效果**\n\n  + 文本阴影\n\n    `text-shadow:5px 5px 5px 颜色(水平方向|垂直方向|阴影程度|阴影颜色)`\n\n  + 文本溢出\n\n    ```\n    1.超出一行省略\n    \n    overflow：hidden\n    \n    white—space：nowrap\n    \n    text-overflow：cellispsis |clip(表示省略号|裁剪)\n    \n    2.超出两行省略\n    overflow:hidden\n    text-overflow:cellispsis\n    -webkit-box-orient:vertical;\n    -webkit-line-clamp:2;\n    ```\n\n  + 文本换行\n\n    + 长文本换行\n\n      `word-wrap:break-word`\n\n    + 单词拆分换行\n\n      `word-break:break-all`\n\n+ **CSS3网格布局**\n\n  + flex布局，float布局应用于一维布局，网格布局应用于二维布局\n\n  + 父元素属性\n\n    ```\n    1.使用\n    display: grid\n    grid-template-columns:10px 10px 10px;\n    grid-template-rows:10px 10px 10px;表示三行三列\n    2.百分比使用\n    display: grid\n    grid-template-columns:33% 33% 33%;\n    grid-template-row:33% 33% 33%;表示三行三列\n    3.repeat()函数简化\n    display: grid\n    grid-template-columns:repeat(3,33.33%)\n    grid-template-row:repeat(3,33.33%);表示三行三列\n    ```\n\n* **项目实战**\n\n  + <link rel=\"shortcut icon\" href=\"图片地址\" type=\"image/x-icon\">图标\n\n  + link:css 可以导入CSS模板\n\n  + 阿里巴巴矢量库:\n\n  + 引入第三方icon\n\n    ```\n    //根文件html导入\n    `<script src=\"http:复制的地址\"></script>`\n    //使用\n    <svg class=\"icon\" aria-hidden=\"true\">\n        <use xlink:href=\"#xxx\"></use>\n    </svg>\n    ```\n\n    \n\n    ","tags":["HTML和CSS"],"categories":["前端"]}]