[{"title":"CPP入门","url":"/2023/05/14/CPP入门/","content":"\n### :page_facing_up:第一天笔记\n\n1. char数组字符串 的 处理函数用法   字符数组最后一位需要``\\0``占位\n\n```c\nstrcat(\"字符串1\",\"字符串2\");将字符串2拼接到字符数组1中，字符数组1的长度必须能容纳的了加入的字符串2；\nstrcpy(\"字符串1\",\"字符串2\");将字符串2覆盖字符数组1，会覆盖字符数组1里面对应的字符,字符串不能用等号直接赋值\nstrcmp(\"字符串1\",\"字符串2\");有返回值，相等返回0；非零表示不相等\n```\n\n##### :pencil: **结构体**   \n\n结构体是一种自定义数据类型，结构体变量代表的结构体类型的数据对象作为一个整体存储在内存中\n\n成员占各自的内存空间，大小为各自成员所占空间加填充的空间\n\n枚举类型里面就是整型\n\n``typedef``关键字为类型结构起别名\n\n```c\ntypedef struct Student{\n    数据类型 字段名;\n}stu;\nstu 就是 struct Student的同义词\n```\n\n+ 普通结构体变量，访问成员变量：结构体变量.成员名;\n\n+ 指针结构体变量，结构体指针名->成员名，或者(*结构体指针名).成员名\n\n  ``c2 = (struct stu*)malloc(sizeof(struct stu))``，创建一个stu结构体指针名为c2\n\nc++中的结构体可以有封装，给变量加上访问限制符，里面也可以定义方法包，跟类只有默认访问限制符不同，其他都相同\n\n##### :pencil: **共用体**\n\n共用体跟结构体的创建一样，只是关键字不同，union\n\n对成员的访问跟结构体一样\n\n所有成员共占一块内存，大小为成员所占空间大小的最大一个，后面赋值的会覆盖前面的值\n\n##### :pencil: **内存对齐**\n\n目的为了提高代码运行\n\n##### :pencil: **预编译和预编译器**\n\n预编译又叫预处理，完成代码文本的替换工作，处理由#开头的预编译指令，如拷贝#include头文件代码\n\n##### :pencil: **反编译**\n\n编译的逆过程，将编译好的文件还原为源代码\n\n##### :pencil: **宏定义**\n\n由#所表示的代码，#include 是将后面文件的内容拷贝过来替换#include这一行代码，#define 是定义一个常量，是在C语言编译代码之前，由宏编译器执行 <>里面是在系统文件夹里面去找，“ ”是去当前项目头文件下去找，，，定义的#define是字符串替换，将后面的完全替换，宏函数：``#define MAX(x,y) (x)>(y)?(x):(y)``，功能简单，代码短小的时候使用宏函数，或者需要提升效率，宏函数是在编译之前就完成编译\n\n### :page_facing_up:第二天笔记\n\n##### :pencil:**指针**\n\n对于每一个变量，计算机都指定一段内存空间存储变量的值，变量使用这段内存空间的开始地址，我们称之为变量的地址，C语言中叫指针，存储（指向）这段内存的起始地址，二级指针是存放一级指针的地址\n\n1. 一个指针变量，无论它指向的变量占几个字节，该指针变量本身占4个字节（32位），8个字节（64位）\n\n2. 一个变量的地址使用该变量首字节的地址来表示\n\n3. 指针就是地址，地址就是指针。 而地址是内存单元的编号。所以，一个指针占几个字节，等于是一个地址的内存单元编号有多长。\n\n##### :pencil:**函数**\n\n1. 返回值不能是局部变量的地址值，因为在函数执行完，会回收局部变量的内存空间\n2. 值传递不会改变原拷贝的值，地址传递会改变原本的值，&引用可以改变原本的值，&相当于只起别名\n\n##### :pencil:**new申请内存空间**\n\n1. stack里面的操作一般是计算机帮我们完成，会帮我们完成申请内存和回收内存的操作\n\n2. 使用new 申请的空间在完成操作后需要delete掉，需要自己回收内存，在使用前最好NULL判断一下\n\n3. 使用new运算符时必须已知数据类型，new运算符会向系统堆区申请足够的存储空间，如果申请成功，就返回该内存块的首地址，如果申请不成功，则返回零值。\n\n4. new运算符返回的是一个指向所分配类型变量（对象）的指针。对所创建的变量或对象，都是通过该指针来间接操作的，而动态创建的对象本身没有标识符名。\n\n5. new int// //开辟一个存放整数的存储空间,返回一个指向该存储空间的地址。int *a = new int 即为将一个int类型的地址赋值给整型指针a\n\n6. int *a = new int(5) //作用同上,但是同时将整数空间赋值为5\n\n7. 指针变量名=new 类型名[下标表达式] \n\n   delete [ ] 指向该数组的指针变量名;，如果在delete的时候没有加[]则默认值删除这片空间的第一个\n\n##### :pencil:**文件**\n\n1. 文件指针：FILE* 定义一个文件指针，FILE是一个文件结构体\n\n   ```c\n   FILE* fp;\n   fp = fopen(文件名，使用方式);//打开文件\n   fclose(fp);//关闭文件\n   ```\n\n\n### :page_facing_up:第三天笔记\n\n##### :pencil:**const**\n\n1. const修饰基本数据类型，表示常量，定义了就不能发生改变了\n\n2. const修饰指针类型，const修饰谁，谁就不能变了\n\n   ```c\n   int const *p=&x;//这种方式不能改变*p=3所指向内存的值，但是可以改变p的指向p=&a\n   //这种是不能改变值，但是p可以指向别的内存地址\n   int *const p=&x;//这种方式不能改变p的指向，但是可以改变*p里面内存的值\n   //这种是不能指向别的地址，但是可以改变内存里面的值\n   ```\n\n3. const修饰函数参数\n\n4. #define 和const定义的常量有什么区别\n\n   1. #define 是由预编译器检查的，只是将前面的字符串和后面的替换掉，不止有定义常量的这个功能\n   2. const 是由编译器进行检查的，通过数据类型进行检查，相对而言比较严谨，定义常量更推荐这个\n\n##### :pencil:**const与指针**\n\n1. 普通指针 ``int *p``\t\n\n   没有const限定的普通指针只能指向普通类型变量，不能指向const常量\n\n   因为const常量是不能被修改的，只有读的功能，普通指针具有读写两种功能，有修改所指对象的可能性\n\n2. 指向常量的指针 ``const int *p或者 int const *p``    不能修改对象的值\n\n   虽然叫指向常量的指针，但是这种定义既可以指向const常量也可以指向普通类型变量\n\n   指向常量类型是指，定义这个指针的目的是通过指针去访问所指的对象，而无意修改对象的值，所以把对象当做常量来看待\n\n   使用const指针的目的是避免通过指针修改对象值得可能性\n\n3. 常量指针  ``int * const p = &a;``   不能修改指针的值（指针的指向）\n\n   常量指针和const常量类似，在定义的时候必须进行初始化，且整个生命周期指针的值都不会改变（指针的指向）\n\n   使用常量指针的目的是防止指针的值（指针的指向）在后续的使用中被意外修改，而错误的对其他对象进行操作\n\n4. 指向常量的常量指针 ``const int *const p = &a;``\n\n   既是常量指针（不能改变指针的指向），又是指向常量的指针（不能修改对象的值）\n\n   在c++类中的const 成员变量对应的*this指针就是这种\n\n##### :pencil:**#pragma once**\n\n为了避免同一个头文件被包含（include）多次,避免头文件被多次编译而出错\n\n1. :pencil:**类与对象**\n\n   1. 类的定义\n\n      1. 对象和结构体的区别\n         1. 定义时候的关键字不同 类class 结构体struct\n         2. 默认访问权限不同，类是private，结构体public\n\n   2. 封装\n\n   3. 对象\n\n      1. 创建对象 \n\n         在栈中创建一个对象 User user;使用点访问其成员变量，计算机帮我们回收内存\n\n         在堆中创建一个对象 User *user = new User();使用->访问，需要自己回收内存\n\n         1. 一般在heap中创建一个指针，我们需要对齐进行判断NULL再进行处理\n\n\n​      这些你不知道你寄吧java白学了。。。。\n\n### :page_facing_up:第四天笔记\n\n##### :pencil:**函数定义**\n\n1. 类内定义建议编译器内联方式编译\n2. 类外定义\n\n##### :pencil:**命名规范** \n\n1. 类名首字母大写，与文件名同名，函数跟Java方法定义一样，动宾结合\n2. 数据成员以（m_类型）做前缀 int m_i;\n\n##### :pencil:**内联函数   inline** \n\n定义在类内部或者加上inline关键字\n\n编译时将函数体代码和实参替代函数调用语句，相当于直接调用方法，省去查找和返回的时间，逻辑比较简单的时候可以使用内联函数\n\n1. 内联函数和宏函数\n\n   功能效果都一样，宏函数是做简单的字符串替换，需要预编译器，内联函数需要编译器\n\n   内联函数的形参需要加数据类型，宏函数不需要加数据类型存在潜在风险\n\n##### :pencil:**类外定义   inline** \n\n1. 同文件定义\n\n2. 分文件定义\n\n   将类定义在头文件里面，方法只做声明，然后在源文件下进行方法实现\n\n   在头文件中定义，在源文件中进行初始化\n\n##### :pencil:**构造函数**   类内定义 \n\n1. 对象的存储结构\n\n   堆区，栈区，常量区，代码区，全局区\n\n2. 对象初始化    相当于二次写入\n\n   默认构造函数和里面有默认参数会冲突\n\n   使用构造函数在创建对象的时候对对象进行初始化   \n\n3. 这个跟java一样，语法不同而已\n\n##### :pencil:**初始化列表**       \n\n   在对象初始化时，先调用初始化列表在调用构造函数\n\n1. 速度快（推荐）  可以为const常量进行初始化赋值\n\n   ```c\n   // User.h\n   class User{\n   public:\n       User();\n       User(String name,int id,int password);\n   private:\n       string m_strName;\n       int m_userId;\n       const int m_password;\n   }\n   //User.cpp\n   User(){};\n   User::User(string name,int id,int password):m_strName(name),m_userId(id),m_password(password){}\n   ```\n\n2. :pencil:**对象初始化**\n\n   1. 直接初始化 int x = 1024;\n   2. 复制初始化 User user2(user1);\n\n3. :pencil:**拷贝构造函数**\n\n   类名（const 类名&变量名）\n\n   如果没有自定义的拷贝构造函数系统会自动生成，如果有自定义，系统不会自动生成\n\n   当对象直接初始化或者复制初始化的时候，自动调用拷贝构造函数 \n\n   函数传参调用的是拷贝构造函数，实参是一个对象\t\n\n   \n\n4. :pencil:**析构函数**   ~类名\n\n   没有参数，没有返回值，不能重载\n\n   对象销毁的时候析构函数会自动调用，栈中和堆中都会。\n\n   成员变量是一个指针，并且在构造函数的时候为指针申请了空间，我们需要自定义析构函数来为指针释放内存空间，防止内存泄漏\n\n5. :pencil:**对象成员**\n\n   创建对象的时候先调用对象成员的构造函数再调用对象的构造函数，在销毁的时候先调用对象的析构函数再调用对象成员的析构函数\n\n   1. 如果对象成员有自定义构造函数的时候需要用初始化列表的方式先进行初始化操作\n\n6. :pencil:**对象数组**\n\n   1. 堆中创建和栈中创建\n   2. 在堆中创建的对象数组构造函数调用数组长度那么多次，在销毁的时候需要delete [] p，析构函数调用对象个数那么多次; 不加[]的话默认删除数组的第一个元素，析构函数只调用了一次\n\n7. :pencil:**静态数据成员**\n\n   1. 普通数据成员存在栈中或者堆中，静态数据成员存在全局区\n   2. 定义在类的public下面，static修饰，访问的时候不需要实例化对象就可以对其进行访问\n   3. 静态函数里面只能使用静态数据成员，，，，这个跟java一样\n   4. 非静态数据成员可以访问静态数据成员\n\n### :page_facing_up:第五天笔记\n\n##### :pencil:**对象指针成员**\n\n对象指针作为另外一个对象的成员\n\n在构造函数里面为别的对象指针申请内存后，需要在该对象的析构函数里面为对象指针释放内存\n\n##### :pencil:**this指针**\n\n指向实例化对象的首地址，跟java的this基本一样\n\n##### :pencil:**常成员函数**\n\n声明方式是在函数声明后面加一个const，在定义的时候再后面也加一个const，\n\n1. 在常成员函数里面不能对数据成员进行修改，实质是在函数的传参中默认传递一个const *当前对象指针，这类指针无法修改值\n\n2. 加const和不加const同名的函数互为重载\n\n3. 调用常成员函数必须是常对象或者常对象指针或常对象引用，常对象实例：在实例对象的的前面加一个const或者后面\n\n   常对象指针：对象名 const * p = new 对象();，常对象引用：对象名 const &别名= 实例的对象\n\n##### :pencil:**深拷贝和浅拷贝**\n\n1. 浅拷贝（系统默认的拷贝构造函数）\n\n   使用场景：只有简单的成员变量，没有在指针，没有向堆中申请内存\n\n2. 深拷贝（自定义拷贝构造函数）\n\n   在自定义拷贝构造函数的时候，在申请堆内存的时候用传入的对象的指针访问他的成员为其进行初始化\n\n   ```c\n   User::User(const User &c){\n       m_pointer = new UserDo(c.m_pointer->id,c.m_pointer->name);\n   }\n   ```\n\n##### :pencil:**友元函数**        \n\n​    友元是不可传递的，是单向的\n\n1. 全局友元函数：friend 类型  函数名 (参数表);  可以参数列表传当前对象的引用，可以访问private成员属性\n\n2. 友元成员函数：friend 类型  类名：： 函数名 (参数表);，其他类的友元函数，类名表示属于哪个类的\n\n   需要再调用友元函数的那个类前面声明 友元函数的类 class 类名；\n\n3. 目的：希望某些类可以访问自己的私有成员变量，定向暴露\n\n4. 不受访问限定符的限制，尽量写在前面\n\n5. :pencil:**友元类 **  fried 类名；\n\n   当一个类需要深入的去调用另外一个类的时候，并且被调的类也不能被修改，才使用友元类\n\n   友元是一种补救的语法，应该尽量避免，尽量减少友元的声明次数\n\n ##### :pencil:**继承**\n\n默认为私有继承，class A ：private B  一般使用public，权限最大 ，外部调用只限于public部分\n\nprotect只能在当前类或者子类中使用，创建子类的实例无法再外部进行访问\n\n1. 实例化子类的时候先执行父类的构造函数，在销毁对象的时候先执行子类的析构函数\n2. 父类的private下面的成员不会被子类继承，只会继承到子类的不可见位置，但是不能进行访问，就相当于会为他分配内存空间，但无法访问，需要通过父类的可访问函数进行访问\n\n保护继承：protect，父类里面的public和protect部分都继承到子类的protect下，private下面跟public一样\n\n私有继承：private，父类的public和protect都继承到子类的private下面，private继承到不可见地方\n\n##### :pencil:**同名隐藏**\n\n子类的函数名和父类的函数名相同， 子类的函数会将父类的函数隐藏，类似于Java的重写，父类的函数不能被直接调用，可以间接调用，子类实例  . 父类：： 函数；\n\n##### :pencil:**多重继承**\n\n跟Java一样。。。\n\n##### :pencil:**多继承**\n\n子类不只拥有一个父类\n\n1. 都需要声明继承方式public或者protect，子类可以使用所有来自父类的可见属性和方法\n\n### 第六天\n\n##### :pencil:**菱形继承**\n\n存在臃裕\n\n:pencil:**虚继承**\n\n在产生了菱形继承时，virtual加在第二层到第一层的继承关系\n\n+ virtual 在继承public前面加（推荐）\n+ 内存上，a，b、c，d，这种关系中，d中只会有a的一份数据，然后取bc的不同\n+ 解决了访问模糊的问题\n\n:pencil:**虚函数**\n\n父类指针指向子类对象，通过指针调用子类的成员方法的过程叫做多态\n\n在父类的方法上加一个virtual就可以实现上面的行为\n\n+ 父类指针调用子类函数的副作用\n\n  在子类中向堆里面申请了内存空间，而在使用完指针后只调用父类的析构函数，而子类申请的内存不会被释放，产生内存泄漏，所以在父类的析构函数前面声明为virtual，后面释放的时候会先执行子类的析构函数（虚函数），再执行执行子类的父类的析构函数\n\n:pencil:**虚函数的实现原理**\n\n+ :pencil:**函数指针**\n\n  函数存在于代码区，函数二进制代码的首地址存在一个指针中，这个指针就是函数指针\n\n  虚函数表是存放地址的数组也就是函数指针，虚函数指针通过查看虚函数表的方式来调用虚函数，普通函数不占内存，虚函数会占内存\t\n\n+ :pencil:**纯虚函数**\n\n  也叫抽象类，含有纯虚函数的类叫做抽象类，抽象类不能实例化只能被继承，声明为virtual函数，不做定义赋值为0，但是子类继承的时候要调用的话必须再子类中实现这个方法\n\n+ :pencil:**接口类**\n\n  仅含有纯虚函数的类叫做接口类，无成员变量等\n\n  + 抽象类用于表达不完全的实体概念\n  + 接口类用于表达一种强制协议或能力\n\n### 第七天\n\n##### :pencil:RTTI\n\n当看到父类指针的时候，你希望知道他指向的对象的数据类型，因为不同的对象要做不同的处理\n\nCpp的数据类型转换：\n\n+ int y = static_cast<int>(x);基本数据类型\n+ Shape *p1 = new Circle(2.0);   Circle *p2 = dynameic_cast<Circle *>(p);指针类型  （多态中使用）\n+ int x= 1000;   int *q = reinterpret_cast<int *> (x);   将基本数据类型转换为指针类型 （很危险）\n  + const int x = 2;  int *p = const_cast<int *>(&x);  const和非const的转换  （不推荐使用）\n\ntypeid(*对象).name()   判断指针的类型\n\n:pencil:**异常处理**\n\ntry catch 跟Java类似不在多说。\n\n空throw语句只能在catch里面使用，catch处理不了异常，再往外抛，catch(...)放在catch语句的最后面，前面捕获不了的异常都由catch(...)来捕获（一般放在最后面），什么都可以捕获\n\n:pencil:**运算符重载**\n\n关键字``operatpr``\n\n+ 一元运算符\n  + 成员函数做运算符重载，用operator声明一个成员函数，重载实际是调用这个成员函数实现的（是通过对象.的方式调用（参数列表是this指针））\n  + 友元函数做运算符重载，用friend 类 operator（类  &对象的引用）来声明函数（相当于是全局函数里面参数是对象本身）\n\n### 泛型\n\n跟java的泛型使用是基本类似的\n\n+ 函数模板\n  + 泛型编程\n  + 定义一个函数模板   template <typename  T 或者 class T，后面还可以加模板参数（相当于常数） >\n+ 模板函数\n  + 把定义的函数模板进行实例化\n+ 类模板\n  + 声明为模板类后他的函数定义也需要声明为函数模板\n  + 使用类模板的时候需要把类的定义和方法的实现都写在头文件里面，不然编译会报错\n+ 模板类\n  + 实例化一个类模板\n\n### vector\n\n对数组的封装\n\n读取能在常数时间完成\n\n遍历vector：\n\n+ for循环\n\n+ iterator迭代器循环\n\n  ```cpp\n  int main(void)\n  {\n      Vector vec;\n      vec.push_back(\"hello world\");\n      vector<string>::iterator citer = vec.begin();\n      for(;citer!=vec.end();citer++){\n          cout<<*citer<<endl;\n      }\n      return 0;\n  }\n  ```\n\n### list\n\n插入速度快，查询速度慢\n\n函数跟上面那个一样\n\nlist的插入函数\n\n```cpp\nlist<int> list1;\nlist<int>::iterator iter = list1.begin();\nlist1.insert(iter,4);//在iter对象前面插入一个4\nlist1.insert(iter,4，1);//在iter对象前面插入四个1\nlist<int > list2(3,5);//创建一个list2链表对象，并且初始化为3个5\nlist1.insert(iter,list2.begin(),list2.end());//将list2插入到list1中，第二个参数为起始，第三个为终止\n```\n\n\n\n### map\n\n键值对\n\n```cpp\nmap<string,string> map1;\npair<string,string> p1(\"蔡徐坤\",\"偶像练习生\");\npair<string,string> p2(\"吴亦凡\",\"大傻逼\");\nmap<string,string>::iterator iter = map.begin();\nfor(;iter!map.end();iter++){\n    cout<<(*iter).first<<endl;\n}\n```\n\n","tags":["c++"]},{"title":"标准IO","url":"/2023/05/14/标准IO/","content":"\n### 标准I/O\n\n#### 标准IO---流\n\n标准io通过缓冲机制减少系统调用，实现更高的效率\n\nFILE\n\n+ 标准io用一个结构体类型来存放打开的文件信息\n+ 标准io的所有操作都是用FILE进行\n\nFILE又称为流stream\n\n+ 文本流/二进制流\n\n缓冲机制\n\n+ 全缓冲：当缓冲区无数据或者无空间的时候才执行IO操作\n+ 行缓冲：当遇到换行\\n,\\r 的时候将缓冲区的东西写入IO操作，或者当程序结束的时候写入\n+ 无缓冲：不进行缓冲机制\n\n**文件的打开**\n\n+ 占用资源\n\n+ FILE * fopen(const char *path,const char *mode)\n\n  + path：普通文件当前文件不需要加目录，其他要使用绝对路径\n\n  + Mode：\n\n    >“r”：只读方式打开文件，需要文件必须存在    **只读推荐**\n    >\n    >“w”：只写方式打开文件，若文件存在则长度清零，若文件不存在，创建文件    **只写一次推荐**\n    >\n    >“a”：只写的方式打开文件，若文件不存在就创建文件，存在就将写入的插入到文件，末尾  **追加文件推荐**\n    >\n    >\"r+\"：读写方式打开，文件必须存在，但是写入后会覆盖原本的\n    >\n    >\"w+ \"：读写方式打开文件，其他同w\n    >\n    >“a+”: 读写方式打开文件，其他同a\n    >\n    >返回值：出错返回NULL，使用fopen函数需要做非空判断\n\n**文件的关闭**\n\n+ 释放资源\n\n+ int fclose(FILE *stream)\n\n  >成功返回0，错误返回负数，并设置error\n  >\n  >流关闭时自动刷新缓冲中的数据，并释放缓冲区\n  >\n  >当一个程序正常终止，所有打开的流都会关闭，比如常规文件把缓冲区的数据写入磁盘\n  >\n  >流一旦关闭就无法执行任何操作\n\n+ 入参必须是非空的，不然会报段错误\n\n**读取字符**\n\n读取一个字符：\n\n> int fgetc(FILE * stream) ；\n>\n> int getc(FILE *stream);宏定义函数\n>\n> int getchar(void) ；  键盘等获取 ,等于标准输入输出，会阻塞等待键盘输入\n\n```c\n#include <stdio.h>\n\n//srdiotest: fgetc()\nint main(void)\n{\n        FILE *fp = NULL;\n        int ret = -1;\n        //open a file\n        fp = fopen(\"1.txt\",\"r\");\n        if(NULL == fp)\n        {\n                perror(\"fopen:\");\n                return 1;\n        }\n        //get a char from file\n        ret = fgetc(fp);\n        if(-1==ret)\n        {\n                perror(\"fgetc:\");\n                return 1;\n        }\n        printf(\"The char is : %d\\n\",ret);\n\n        //close the file\n        fclose(fp);\n\n        return 0;\n}\n```\n\n\n\n写入一个字符\n\n>int fputc(int c，FILE *stream);\n>\n>int putc(int c，FILE *stream);\n>\n>int putchar(int c);     等于标准输入输出\n\n```c\n#include <stdio.h>\n\n//stdiotest: fputc()\nint main(void)\n{\n        FILE *fp = NULL;\n        int ret = -1;\n        //open a file with append\n        fp = fopen(\"1.txt\",\"a\");\n        if(NULL == fp)\n        {\n                perror(\"fopen:\");\n                return 1;\n        }\n        int w = 'c';\n        //write this char into the file\n        ret = fputc(w,fp);\n        if(-1==ret)\n        {\n                perror(\"fputc:\");\n                return 1;\n        }\n        printf(\"This char is : %c\\n\",ret);\n\n        //close this file\n        fclose(fp);\n        return 0;\n}\n```\n\n\n\n**按行读写**\n\n按行读取：\n\n>char *gets(char *s); *s表示读到哪里,从键盘读   //已经淘汰，会导致缓冲区溢出\n>\n>char *fgets(char *s,int size,FILE *stream)//会计算\\0,没填满的话，就加入\\n\n>\n>成功返回s，到文件末尾或者出错返回NULL\n\n```c\n#include <stdio.h>\n#include<string.h>\n\n//srdiotest: fgets()\nint main(void)\n{\n        FILE *fp = NULL;\n        char * ret = NULL;\n        char buf[100];\n        memset(buf,0,100);\n        //open a file\n        fp = fopen(\"1.txt\",\"r\");\n        if(NULL == fp)\n        {\n                perror(\"fopen:\");\n                return 1;\n        }\n        //get a char from file\n        ret = fgets(buf,21,fp);\n        if(NULL==ret)\n        {\n                perror(\"fgets:\");\n                return 1;\n        }\n        while(NULL!=ret){\n            printf(\"The string is : %s\",buf);\n\n        ret = fgets(buf,5,fp);\n        }\n\n        //close the file\n        fclose(fp);\n\n        return 0;\n}\n```\n\n\n\n按行写入：\n\n> int fputs(const char *s,FILE *stream);//将s写入到文件中\n>\n> 成功返回非负整数，出错返回负数\n\n```C\n#include<stdio.h>\n#include<string.h>\n\n//stdiotest: fputs()\nint main(void)\n{\n        FILE *fp = NULL;\n        char *str = \"yzpcode.xyz is the best!\";\n        int ret = -1;\n        //open a file\n        fp = fopen(\"1.txt\",\"a\");\n        if(NULL==fp)\n        {\n                perror(\"fopen:\");\n                return 1;\n        }\n        //write this string into the file\n        ret = fputs(str,fp);\n        if(-1==ret)\n        {\n                perror(\"fputs:\");\n                return 1;\n        }\n        printf(\"write into file success!\\n\");\n        //close the file\n        fclose(fp);\n\n        return 0;\n}\n```\n\n\n\n二进制读写：\n\n按对象读写：\n\n> size_t fread (void * ptr,size_t size,size_t n,FILE* f);  *ptr表示读到哪里，size表示读取块多大，n表示多少个，f表示从哪里读\n>\n> size_t fwrite (const void * ptr,size_t size,size_t n,FILE* f);  *ptr写的内容位置指针，f表示写到哪里\n>\n> 成功返回读写的个数，失败返回负数\n>\n> 既可以读写文本文件，也可以读写数据文件\n>\n> 注意事项：文件写完过后，文件指针指向文件末尾，如果这时候直接读取文件，会读不出来\n>\n> 解决办法：移动指针，关闭文件重新打开文件\n\n写：\n\n```c\n#include<stdio.h>\n#include<string.h>\n\n//stdio: fwrite()\n\nstruct User {\n        char name[30];\n        int age;\n        char sex[10];\n};\n\nint main(void)\n{\n        FILE *fp = NULL;\n        size_t ret = -1;\n        struct User user1;\n        strcpy(user1.name,\"yzpcode\");\n        user1.age  = 20;\n        strcpy(user1.sex,\"man\");\n\n        //open a file \n        fp = fopen(\"1.bin\",\"w\");\n        if(NULL==fp)\n        {\n                perror(\"fopen:\");\n                return 1;\n        }\n        //write into file\n       ret = fwrite(&user1,sizeof(user1),1,fp);\n        if(-1==ret)\n        {\n                perror(\"fwrite:\");\n                return 1;\n        }\n        printf(\"The len is : %ld\\n\",ret);\n\n        //close the file\n        fclose(fp);\n\n        return 0;\n}\n```\n\n读：\n\n```c\n#include<stdio.h>\n#include<string.h>\n\n//stdio: fwrite()\n\nstruct User {\n        char name[30];\n        int age;\n        char sex[10];\n};\nint main(void)\n{\n        FILE *fp = NULL;\n        size_t ret = -1;\n        struct User user1;\n\n        //open a file \n        fp = fopen(\"1.bin\",\"r\");\n        if(NULL==fp)\n        {\n                perror(\"fopen:\");\n                return 1;\n        }\n        //read the file\n        ret = fread(&user1,sizeof(user1),1,fp);\n        if(-1==ret)\n        {\n                perror(\"fread:\");\n                return 1;\n        }\n        printf(\"The len is : %ld\\n\",ret);\n        printf(\"The user is: name:%s   age:%d   sex:%s  \\n\",user1.name,user1.age,user1.sex);\n        //close the file\n        fclose(fp);\n\n        return 0;\n}\n\n```\n\n#### 标准流的刷新\n\n+ int fflush（FILE* f）\n+ 将缓冲区的数据写入文件\n\n#### 标准流的定位\n\n+ long ftell(FILE *fp)// 返回当前流的读写位置\n\n+ long fseek(FILE*stream,long offset, int whence)\n\n  >offset 表示偏移量，可正可负\n  >\n  >whence 表示在那个位置，   SEEK_SET  开头    SEEK_CUR  当前     SEEK_END 结尾\n  >\n  >当文件以a模式打开fseek无效\n\n+ void rewind(FILE *fp)\n\n  > 相当于 fseek(fp,0,SEEK_SET)\n\n+ 这三个函数只适用于2G以下的文件\n\n标准流的格式化输入输出\n\n+ 输出\n\n  >sprintf(buf,\"%d-%d-%d\",2023,4,16);//输入到buf数组    用的较多    将数据以格式输入\n  >\n  >fprintf(fp,\"%d-%d-%d\",2023,4,16)//输入到fp文件\n\n+ 输入\n\n  >int sscanf(buf,\"%d-%d-%d\",&year,&month,&day);  //变量需要加地址符 ，将buf取出数据按格式赋值给变量\n  >\n  >取一定数据进行格式\n  >\n  >int  fscanf(fp,\"%d-%d-%d\",&year,&month,&day) //从文件中读取数据赋值给变量\n\n#### 时间\n\n+ time() 获取时间戳\n\n  >返回值为long int\n\n+ localtime(&time)    ;  将时间戳转换为系统时间\n\n  >返回的是一个struct tm* 结构体 指针  \n\n写入到时间需要刷新缓冲区","tags":["Linux"]},{"title":"Linux文件IO","url":"/2023/05/14/Linux文件IO/","content":"### Linux文件和系统调用\n\n#### 系统调用和库函数的区别\n\n+ 系统调用：操作系统提供给用户程序的一组特殊接口\n\n  >用户态，内核态\n  >\n  >操作系统一般通过软件中断来切换\n\n+ 库函数\n\n  >1. 需要调用系统调用：不需要切换内核态\n  >2. 需要调用系统调用：需要切换为内核态\n\n+ 错误处理函数errno，全局变量，定义在<errno.h>，记录系统程序最近一次出错的状态码，是一个整型int，可以通过strerror(errno)函数将对应的出错信息显示出来，也可以使用perror() 函数，里面可以加字符串提示，效果是一样的\n\n+ 虚拟地址：\n\n  在进程里面平时的指针变量，保存的时虚拟地址，当应用程序使用虚拟地址访问内存的时候，cpu会将虚拟地址转化为物理地址\n\n  >MMU：将虚拟地址转化为物理地址\n  >\n  >好处：\n  >\n  >1. 进程隔离，更好的保护系统安全运行\n  >2. 方便操作系统和编译器安排进程地址\n\n#### 文件\n\n+ 文件描述符：非负的整数，是文件的标志，操作文件描述符等于操作这个文件,0,1,2 已经被系统使用\n\n+ 最大打开文件：\n\n  >查看： cat  /proc/sys/fs/file-max\n  >\n  >查看当前默认设置最大打开文件个数：ulimit -a\n  >\n  >修改默认设置最大打开文件个数 ： ulimit -n  4096\n\n#### 常用的IO函数\n\n### 16.1 open函数\n\n```c\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nint open(const char *pathname, int flags);\nint open(const char *pathname, int flags, mode_t mode);\n功能：\n    打开文件，如果文件不存在则可以选择创建。\n参数：\n    pathname：文件的路径及文件名\n    flags：打开文件的行为标志，必选项 O_RDONLY, O_WRONLY, O_RDWR\n    mode：这个参数，只有在文件不存在时有效，指新建文件时指定文件的权限\n返回值：\n    成功：成功返回打开的文件描述符\n    失败：-1\n```\n\n**flags详细说明**\n\n必选项：\n\n| **取值** | **含义**               |\n| :------- | :--------------------- |\n| O_RDONLY | 以只读的方式打开       |\n| O_WRONLY | 以只写的方式打开       |\n| O_RDWR   | 以可读、可写的方式打开 |\n\n可选项，和必选项按位或起来\n\n| **取值**   | **含义**                                                   |\n| :--------- | :--------------------------------------------------------- |\n| O_CREAT    | 文件不存在则创建文件，使用此选项时需使用mode说明文件的权限 |\n| O_EXCL     | 如果同时指定了O_CREAT，且文件已经存在，则出错              |\n| O_TRUNC    | 如果文件存在，则清空文件内容                               |\n| O_APPEND   | 写文件时，数据添加到文件末尾                               |\n| O_NONBLOCK | 对于设备文件, 以O_NONBLOCK方式打开可以做非阻塞I/O          |\n\n**mode补充说明**\n\n\\1) 文件最终权限：mode & ~umask\n\n\\2) shell进程的umask掩码可以用umask命令查看\n\nØ umask：查看掩码（补码）\n\nØ umask mode：设置掩码，mode为八进制数\n\nØ umask -S：查看各组用户的默认操作权限\n\n| **取值** | **八进制** | 含义                                   |\n| :------- | :--------- | :------------------------------------- |\n| S_IRWXU  | 00700      | 文件所有者的读、写、可执行权限         |\n| S_IRUSR  | 00400      | 文件所有者的读权限                     |\n| S_IWUSR  | 00200      | 文件所有者的写权限                     |\n| S_IXUSR  | 00100      | 文件所有者的可执行权限                 |\n| S_IRWXG  | 00070      | 文件所有者同组用户的读、写、可执行权限 |\n| S_IRGRP  | 00040      | 文件所有者同组用户的读权限             |\n| S_IWGRP  | 00020      | 文件所有者同组用户的写权限             |\n| S_IXGRP  | 00010      | 文件所有者同组用户的可执行权限         |\n| S_IRWXO  | 00007      | 其他组用户的读、写、可执行权限         |\n| S_IROTH  | 00004      | 其他组用户的读权限                     |\n| S_IWOTH  | 00002      | 其他组用户的写权限                     |\n| S_IXOTH  | 00001      | 其他组用户的可执行权限                 |\n\n### 16.2 close函数\n\n```c\n#include <unistd.h>\n\nint close(int fd);\n功能：\n    关闭已打开的文件\n参数：\n    fd : 文件描述符，open()的返回值\n返回值：\n    成功：0\n    失败： -1, 并设置errno\n```\n\n\n\n需要说明的是，当一个进程终止时，内核对该进程所有尚未关闭的文件描述符调用close关闭，所以即使用户程序不调用close，在终止时内核也会自动关闭它打开的所有文件。\n\n但是对于一个长年累月运行的程序(比如网络服务器)，打开的文件描述符一定要记得关闭,否则随着打开的文件越来越多，会占用大量文件描述符和系统资源。\n\n### write函数\n\n```C\n#include<stdio.h>\n#include<stdlib.h>\n#include<sys/stat.h>\n#include<sys/types.h>\n#include<fcntl.h>\n#include<unistd.h>\n#include<string.h>\n\n//iotest: write()\nint main(void)\n{\n        int fd = -1;\n        int ret = -1;\n\n        char *str = \"hello yzpcode.xyz codeboy!\";\n\n        //opne a file \n        fd = open(\"yzp\",O_WRONLY|O_CREAT,0644);\n        if(-1 == fd)\n        {\n                perror(\"open: \");\n                return 1;\n        }\n        printf(\"open file success!\\n\");\n        //write into file\n        ret = write(fd,str,strlen(str));\n        if(-1 == ret)\n        {\n                perror(\"write: \");\n                return 1;\n        }\n        printf(\"write into file success!\\n\");\n        printf(\"str len : %d\\n\",ret);\n\n        printf(\"hello world!\\n\");\n        close(fd);\n        return 0;\n}\n```\n\n### read函数\n\n```C\n#include<stdio.h>\n#include<stdlib.h>\n#include<sys/stat.h>\n#include<sys/types.h>\n#include<fcntl.h>\n#include<unistd.h>\n#include<string.h>\n\n#define SIZE 100\n\n//iotest: read()\nint main(void)\n{\n        int fd = -1;\n        int ret = -1;\n        char buf[SIZE];\n        memset(buf,0,SIZE);\n\n        //opne a file \n        fd = open(\"yzp\",O_RDONLY);\n        if(-1 == fd)\n        {\n                perror(\"open: \");\n                return 1;\n        }\n        printf(\"open file success!\\n\");\n        //read  file\n        ret = read(fd,buf,SIZE);\n        if(-1 == ret)\n        {\n                perror(\"read: \");\n                return 1;\n        }\n        printf(\"read file success!\\n\");\n        printf(\"file len is: %d file content : %s\\n\",ret,buf);\n\n        printf(\"hello world!\\n\");\n        close(fd);\n        return 0;\n}\n```\n\n### 文件定位\n\n+ 定位光标\n\n>off_t  lseek(int fd,off_t offset,intt whence)\n>\n>SEEK_CUR : 当前位置进行偏移\n>\n>SEEK_SET:  从文件开始进行偏移\n>\n>SEEK_END:  从文件末尾进行偏移\n\n+ lseek(fd,0,SEEK_SET)\n\n## 访问目录\n\n1. 打开目录 : opendir\n\n> #include<dirent.h>\n>\n> DIR * opnedir(const char*name)   // 目录的名字\n>\n> 返回值目录流指针，跟FILE流指针一样，失败返回NULL\n\n2. 读取目录：readdir\n\n> #include<dirent.h>\n>\n> struct dirent * readdir(DIR * dirp)   //返回值是一个结构体\n>\n> 成功返回目录流中的下一项，出错或者到末尾返回NULL\n\n## 修改文件访问权限\n\n1. 修改文件访问权限：\n\n> #include<sys/stat.h>\n>\n> int chmod(const char *path,mode_t mode)\n>\n> int fchmod(int fd,mode_t mode) \n>\n> 成功返回0，出错返回负数\n>\n> root 和文件所有者才能修改文件的访问权限： chmod (\"yzp.txt\",0641)\n\n## 获取文件属性\n\n1. 获取文件属性\n\n> #inlcude<sys/stat.h>\n>\n> int stat(const char*path,struct stat *buf)\n>\n> int lstat(const char *path,strucr stat *buf)   // 获取文件属性放到stat结构体中\n>\n> int fstat(int fd,struct stat *buf)      //从文件中 获取\n>\n> 成功返回0，出错时返回负数\n>\n> 如果path 是符号链接stat获取的是目标文件的属性，而lstat获取的是链接文件的属性\n\n2. 通过 stat结构体st_mode 判断是什么类型","tags":["Linux"]},{"title":"Vim","url":"/2023/05/14/Vim/","content":"### vim\n\n+ vim的三种模式：编辑模式，末行模式，命令模式\n\n+ 基本操作：\n\n  + 打开文件  vim  文件名     // 显示文件内容末行模式      如果没有文件就创建一个新的文件\n\n  + 保存文件    在编辑文件后 按esc  然后shift  + zz\n\n\n\n#### vim下进行编程\n\n+ 分屏：vsp  文件名\n+ 批量删除 \n\n> : 10 , 15d\n\n+ 批量复制\n\n> : 10 ,15y\n\n+ 批量注释 //\n\n> ### :  10 , 15s#^#//#g\n\n+ 批量删除注释  //\n\n> :10,20s#^//##g\n\n+ 批量注释  ##\n\n> :10,20s/^/#/g\n\n+ 批量删除注释 ##\n\n> :10,20s/#//g\n\n### GCC\n\n#### GCC工作流程\n\n+ 四个阶段\n\n  + 预处理  cpp： 头文件展开，宏替换，去掉注释      gcc  -E  hello.c -o hello.i\n  + 编译器  gcc ： c文件变成汇编文件                           gcc - S   hello.c  -o  hello.s\n  + 汇编译   as ：汇编文件变成二进制文件                   gcc  - c  hello.c -o  hello.o\n  + 链接器   ln ： 将函数库中相应的代码组合目标文件生成可执行文件          \n\n+ //编译gcc  hello.c -o hello    // 执行   ./hello   \n\n  -D  : 编译的时候定义宏    -Wall  提示更多警告信息    -Wall -Werror  将警告变成error 处理\n\n#### 静态连接和动态链接\n\n+ 静态链接 ： 在编译的时候将所有库的内容 加载进来   \n\n  版本依赖少， 内存占的多 \n\n+ 动态链接： 在需要库的时候再进行加载库\n\n##### 制作静态库\n\n+ 命名规则：\n  + 前缀：lib\n  + 库名称：自定义\n  + 后缀 ： .a\n  + 最终为：libxxx.a\n+ 先生成对应的二进制文件，最后打包生成静态库： ar   -rsc   libtest.a   a.o b.o c.o\n  + 参数： r  更新     c 创建    s建立索引\n\n##### 静态库的使用\n+ gcc  -test.c  -I(大i)./   -L./  -l(小L)库的名字\n  + 大i  : 表示所需的头文件再当前目录\n  + L：表示要连接的库所在目录\n  + 小L： 指定链接需要的库，去掉前缀和后缀\n\n##### 动态库的制作   \n程序运行的时候才会被载入\n+ 第一步：生成对应的二进制文件 ：   gcc   -fpic  -c   add.c\n  + 参数：fpic  创建与地址无关的编译程序，为了能在多应用程序之间共享\n+ 第二步：链接生成对应的动态库：  gcc  -shared  add.o   sub.o  -o   libaa.so \n  + 参数： -shared   指定生成动态链接库\n  + 前缀    lib     动态库名     后缀：.so\n+ 使用 nm  查看对应的函数      :   nm  libaa.so    | grep \"add\"  \n+ ldd  ： 查看可执行文件所依赖的库\n+ 第三步：使用动态库： gcc  test.c -I ./  -L ./  -laa    会报错\n\n### GDB\n\n​    进入调试界面：  gdb   可执行文件\n\n+ 进行调试\n  + set  args  设置运行时参数\n  + show  args   显示设置的参数\n  + run    程序开始执行，如果有断点就在断点处\n  + start  程序向下执行一行\n+ 显示源代码：\n  + 通过list  查看  默认只打印10行\n  + list  行数      打印第 多少行的上下文内容\n  + lis  函数名    打印函数的源代码\n  + list-  ： 显示当前行之前的源代码\n  + list   显示当前后的源代码\n  + 设置一次显示多少行  ：\n    + set  listsize  count   \n    + show  listsize \n+ 设置断点\n  + 使用break  简写b\n  + b   行数    表示在源代码的第多少行打断点\n  + b   函数名     表示在函数处打断点\n+ 多文件设置断点\n  + break   文件名：第几行      表示在源代码第几行设置断点\n  + break   文件名：函数名      表示在源代码的函数入口处设置断点\n+ 查询断点\n  + info   b\n  + i  b\n+ 设置条件断点：b  test.c:    23  if  i==5;       表示当第23行i = 5的时候就停下断点\n+ 维护断点\n  + delete   可以加指定范围       delete 7            delete  7-10    删除断点\n  + disable    断点号         使断点停用\n  + enable     断点号         使断点可以用\n\n##### 调试代码\n\n+ run ： 运行程序   简写r\n+ next：单步跟踪，函数调用当做一条简单语句执行，  简写 n\n+ step：单步跟踪，函数调进入被调函数体内，简写s\n+ finish： 退出进入的函数\n+ until   ： 在一个循环体单步跟踪，这个命令可以跳出循环体，简写u\n+ continue ： 继续运行程序，停留在下一个断点处，简写c\n+ quit： 退出gdb，可以简写q\n+ 查看运行中的值： print   打印变量，字符串，表达式的值 ，简写p\n\n##### 自动显示\n\n设置\t一些自动显示的变量，当程序运行时，或者单步追踪的时候，自动显示\n\n+ display   变量名\n+ info   display        显示设置display 的信息\n+ undisplay    num  （info  的时候显示的num）     不在显示\n+ delete   display  num            删除自动显示\n+ disable   display  num          禁止 自动显示\n+ enable    display   num         允许自动显示\n+ disable  和 enable  不删除自动显示的设置，只是让他失效或者恢复\n\n##### 查看修改变量的值\n\n+ ptype  i     //查看i的数据类型\n+ p   i    // 查看i的值\n+ set  var  i = 10     //将变量i 设置为10","tags":["Linux"]},{"title":"Makefile","url":"/2023/05/14/Makefile/","content":"### Makefile\n\n#### 主要解决的时间\n+ 大量代码的维护\n+ 减少重复编译时间\n+ Makefile 命名规则  ： makefile  或者  Makefile\n+ make安装 ： sudo  apt  install  make\n#### Makefile语法规则\n+ 一条规则，三要素\n+ 规则\n  > 目标：依赖文件目录\n  >\n  > <Tab> 命令列表\n+ 三要素\n  + 目标： 通常是要产生的文件名称，目标可以 是可执行文件或其他obj文件，也可以是一个动作的名称\n  + 依赖文件： 用来输入从而产生目标文件，一个目标通常有有几个依赖文件（可以没有）\n  + 命令： make执行的动作，一个规则可以含有几个命令（可以没有），每个命令占一行\n#### Makefile命令格式\n  + make  [-f file]  [options] [targets]\n1. -f    : 指定以上名字以外文件作为Makefile输入文件\n2. [options]:\n   + -v  显示make版本信息\n   + -w：在处理Makefile之前和之后显示工作路径\n   + -C  dir   ：  在读取Makefile文件之前将工作路径改为dir\n   + -n ： 只打印要执行的命令但不执行\n   + -s   ：执行但不显示执行\n3. [targets]:\n   + 若使用make命令的时候没有指定目标，默认为第一个目标文件\n   + make  aa  -f  1.mk\n#### Makefile中的函数\n两个最常用的\n+ wildcard： 查询指定目录下的指定文件\n  >src = ${wildcard *.c}\n  >\n  >//找到当前目录下所有后缀为.c 的文件，赋值给src\n+ patsubst： 匹配替换\n  > obj = ${patsubst %.c , %.o,${src}} \n  >\n  > //将src变量里面所有.c 后缀的文件全部替换为.o文件\n#### Makefile中的伪函数\nclean用途: 清除编译生成的中间.o文件和最终目标文件\nmake clean 如果当前目录下有同名clean文件，则不执行clean对应的命令，解决方案：\nØ **伪目标声明:** **.PHONY:clean**\n声明目标为伪目标之后，makefile将不会该判断目标是否存在或者该目标是否需要更新\n**clean命令中的特殊符号：**\n- “-”此条命令出错，make也会继续执行后续的命令。如:“-rm main.o”\n- “@”不显示命令本身,只显示结果。如:“@echo clean done”\n```linux\nSRC=$(wildcard *.c)\nOBJS=$(patsubst %.c, %.o, $(SRC))\nTARGET=test\n$(TARGET):$(OBJS)\n    gcc $(OBJS) -o $(TARGET) \n\n%.o:%.c\n    gcc -c $< -o $@\n.PHONY:clean\nclean:\n    rm -rf $(OBJS) $(TARGET)\n```\n\n总结：一条规则，两个函数，三个变量","tags":["Linux"]},{"title":"Linux基础","url":"/2023/05/14/Linux/","content":"### Ubuntu\n\n+ pwd：查看当前目录\n+ cd ：切换目录   / 开头绝对路径   . 当前目录  ../返回上级目录\n+ mkdir ： 创建目录   -p 创建多级目录\n+ whoami  : 查看当前用户\n+ stat  ： 查看文件相关属性\n+ which ： 查看文件的路径\n+ chmod: 修改文件权限     chmod  444 test      // 4  2  1    w   r   x\n+ file  ：   查看文件类型\n+ rmdir：删除目录  （不能删除非空目录）  rm -rf 可以删除非空目录\n+ ls ： 查看信息  ls -l 查看详细信息   ls -a 查看全部信息  ls -lh   h表示内存大小\n+ touch : 创建文件，如果存在就更新文件时间\n+ cp ： v显示进度 f 强制  r 递归 （目录拷贝需要递归）\n  + cp  file dir/   如果dir下有同名文件默认覆盖\n  + cp -i file dir/ 提示是否覆盖\n  + cp file1 file2  dir/   将多个文件拷贝到\n  + cp -r dir1 dir2  将目录1 拷贝到目录2中\n+ rm ：删除文件或目录  （默认强制删除）\n  + -i：提示是否删除\n  + -r：递归的删除目录下的内容，删除文件夹必须加这个\n  + -f：强制删除\n+ mv : 移动文件或目录 \n  + -i : 提示是否覆盖\n  + -f ：强制\n  + -v：显示进度\n  + mv file1 file2   将file1改名为file 2\n  + mv file dir/  将file移到dir下\n+ cat ：将文件信息输出给终端\n  + -n ：对输出的所有进行编号\n  + -b ： 给输出的非空行进行标号\n  + -A : 会打出换行符\n+ more （不推荐使用）：查看，不能回退查看文件\n+ less：将文件内容分页展示给终端\n  + ctrl+n   向下滑\n  + ctrl +p 向上滑\n  + q   退出\n+ head ： 查看文件从开始到第n行\n  + head -n 文件\n  + -c  查看多少个字符\n  + -f 动态显示\n  + -q  ：不显示头信息\n  + -v 显示头信息\n+ tail ：从文件底部开始查看\n  + tail -n 5 file  查看文件最后五行\n  + 没有指定n的值的话，默认查看最后十行，其他跟head一样\n+ du ：查看目录大小\n  + du -sh 文件    查看指定文件或者数据块的大小并加上单位\n  + -a 递归显示指定目录个文件和子目录所占用的数据块\n  + -s\n  + -b  以字节为单位显示磁盘\n  + -h 以k，m，g为单位\n+ df ： 查看文件磁盘空间占用和可用情况\n  + df -h\n+ find： 非常实用，查看文件\n  + find + 路径+ -name +“文件名”\n  + find+路径+ -size +范围            +100k表示大于100k，-100k表示小于100k，k小写，M大写  -size +50k  -size -100k 50k到100k之间\n  + find + 路径+ -type +类型\n    普通文件是用f 而不是_         d目录 l 符号链接 c块设备文件 c字设备文件  s socket文件  p管道 \n+ grep ： 匹配进行查找\n  + grep + 选项+ ‘ 搜索的内容串 ’ + 文件名\n    + -i  忽略大小写\n    + -v  不包含搜索的内容\n    + -n  包含搜索的内容的行号\n    + 搜索目录的时候需要加  -r\n    + -a 二进制文件\n    + -w 完全匹配的那一行\n+ 管道   | ：一个命令的输出可以作为另一个命令的输入\n+ tar： linux中最常用的备份工具，把一系列文档归档到一个大文件中，也可以将档案文件解开恢复数据\n  格式：tar 选项打包文件名  文件\n  + -c  生成档案文件 ，创建打包文件\n  + -v  列出打包的过程  进度\n  + -f   指定档案文件名称  ，f 后面一定跟的是.tar文件，所以必须放选项最后\n  + -t   列出档案中包含的文件\n  + -x   解开档案文件\n  一般组合使用：\n  + tar -cvf  yzpcode.tar   yzpcode    // 打包\n  + tar -xvf  yzpcode.tar    // 将打包的文件归档还原\n  + tar  -tvf  yzpcode.tar   // 查看里面是否有自己需要的文件\n+ gzip ：tar与gzip命令结合使用 实现文件打包和压缩    大文件一般使用gzip\n  + 默认是压缩  后面直接跟需要压缩的文件，不保留原文件压缩\n  + tar 只负责打包文件不负责压缩，gzip负责压缩tar打包后的文件 ， 其扩展名 一般为 ##.tar.gz\n  + 格式： gzip   选项  被压缩的文件\n    + -d  解压\n    + -r   压缩所有子目录\n  + 目录一定要先打包在压缩\n  + **组合使用**：\n    + tar  -czvf   yzpcode.tar.gz  yzpcode    // 先打包再进行压缩     可以指定压缩到哪里需要使用绝对路径\n    + tar  -xzvf   yzpcode.tar.gz   //对压缩后的文件进行解压    如果需要指定解压到哪一个目录 在后面 加   -C  路径\n+ bzip2 ： 跟gzip 相同   后缀名不一样为  .bz2     小文件一般使用 bzip2\n  + 结合tar  ： 压缩 ： tar -jcvf   yzpcode.tar.bz2   yzp\n  + 解压：tar -jxvf  yzpcode.tar.bz2\n  + 万能解压   ：   tar -xvf     万能解压（可以解压gzip和bzip2）\n+ zip 和 unzip  ：\n  + zip  myzip    文件...     myzip就是压缩文件名称 不需要加后缀，后面的文件可以跟多个，打包和压缩到myzip\n  + unzip  myzip.zip    解压文件    unzip -d  路径   myzip.zip  加压文件到指定路径\n+ 访问权限：\n  + r  ： 读权限  \n    + 文件：具有读取文件内容的权限\n    + 目录： 具有浏览目录的权限\n  + w： 写权限\n    + 文件：具有新增，修改的权限\n    + 目录：具有删除，移动目录内文件的权限\n  + x  ： 可执行权限\n    + 文件：具有文件执行的权限\n    + 目录：该用户有进入目录的权限\n  只允许文件的所属者或者超级管理员可以修改文件的读写权限\n+ chmod （需要熟练）：改变文件权限\n  + 字母法：chmod  u/g/o/a  +/-/=  rwx\n    + u  :  文件的所有者\n    + g ： 与user 同组的\n    + o  ： 其他以外的人\n    + +：新增权限\n    + -：撤销权限\n    + =：设定权限\n    例子：chmod o+w   a.txt   为文件a的其他用户增加写的权限\n    chmod u=rw,g=r,o=r a.txt  设置user可读写，组内可读，外面可读\n  + 数字法：chmod   764   a.txt    \n    + rwx     111   ====》7\n    + rw-      110 =====》 6\n    + r--       100  =====》 4 \n    + r-x      101  ====》5\n  + 修改目录 和 里面文件的权限   chmod  -R  777  test/\n+ chown  ： 修改目录所有者   sudo  chown  root  a.txt    // 将a.txt 的所属者修改为root    \n  sudo  chown : root a.txt  //将a.txt 的所属组改为root\n+ 重定向：\n  + 标准输出是显示到屏幕上，使用  ls   内容    >  文件名    ，将ls 显示的内容   输入到文件中显示，但是会覆盖文件原本的内容，，如果不想覆盖  就使用  >>  追加到文件里面\n  + 标准错误输出，ls  dasf     （使用2>）2>>  文件    将错误输出到文件里面， 一般丢在黑洞文件里面   /dev/null\n+ ln (掌握):\n  + 软连接不占磁盘空间，原文件删除软链接失效  \n  + 硬链接只能链接普通文件，不能链接目录\n  + ln  源文件  链接文件    //硬链接\n  + ln  -s 源文件  链接文件    // 软连接   并没有存储文件的数据，只存储文件的路径   readlink  可以读取符号链接的内容（存储目标文件的路径）","tags":["Linux"]},{"title":"C语言进阶","url":"/2023/04/06/C语言进阶/","content":"### C进阶\n\n#### 数据类型\n\n+ 声明数据类型是为了更好的管理内存，为数据分配合理的内存空间\n+ 定义的数据都得有一种数据类型\n+ 创建变量的模具，**固定大小内存的别名**，即int a = 10；是分配一个4个字节的内存空间，里面存的数据为10(里面用16进制表示0)，然后用别名 a来操作这段内存\n\n#### typedef\n\n实际就是起一个别名来操作\n\n+ 简化结构体的struct关键字\n+ 区分数据类型   typedef char * Pchar;\n+ 提高移植性，当需要修改特定的时候 提前用typedef定义后只需要修改定义就行\n\n#### void\n\n+ 无类型   无法定义数据类型，编译器无法知道为数据分配多大的内存\n\n+ 限定函数返回值，限定函数参数\n\n+ 万能指针  void *p=NULL;(任何指针用sizeof调用都是四个字节)\n\n  不同类型的指针需要强转才能转换，void指针可以不通过强制类型转换\n\n#### sizeof\n\n+ 本质不是一个函数，而是一种运算符\n\n+ 在统计类型的时候需要加括号，在统计变量的时候可以不加括号\n\n+ sizeof的返回值是一个unsigned int  无符号整型\n\n  一个unsigned int 和int运算，结果会统一为unsigned int\n\n+ 可以求数组所占内存空间的大小\n\n  当一个数组名传入到函数中作为参数，会被退化为一个指针，这个指针指向该数组首元素的地址，其实数组名就是一个地址\n\n#### 变量的修改\n\n+ 变量本质：一段连续内存空间的别名\n+ 不是向变量名读写数据，而是向变量名所代表的内存空间进行读写数据\n+ 直接修改\n+ 间接修改 ： int *p=&a;   *p=20;// *p是解引用过程，是访问p内存存放的地址所代表的值\n\n#### 内存四区\n\n+ 运行之前：\n  + 预处理：宏定义展开，头文件展开，条件编译，这里并不会检查语法\n  + 编译：检查语法，将预处理后的文件编译成汇编文件\n  + 汇编：将汇编文件生成目标文件（二进制文件）\n  + 链接：将目标文件链接为可执行文件\n+ 代码区：存放cpu执行的机器指令。通常代码区是共享的，共享的目的是频繁被执行的程序只需要在内存中有一份代码就可以，代码区通常是只读的\n+ 全局初始化数据区或者叫做静态数据区（data段）：在程序中被明确初始化的全局变量，已经初始化的静态变量和常量数据\n+ 未初始化数据区（又叫bss区）：存入的是未初始化变量和未初始化静态变量，未初始化数据区在程序执行前被内核初始化为0或者NULL；\n\n+ 运行之后：\n  + 栈区：先进后出，编译器自动分配释放，函数的参数，返回值，局部变量，在生命周期结束的时候自动释放内存，栈容量有限，容易栈溢出\n  + 堆区：大容器，用于动态分配内存，堆在内存中位于bss和栈之间，一般由程序员分配和释放，程序结束时由操作系统回收\n\n#### 栈区的注意事项\n\n+ 在函数里面定义的局部变量不能作为返回值，因为在函数运行结束的时候栈中已经把局部变量的内存释放\n+ 不要返回局部变量的地址值\n\n#### 堆区以及注意的事项\n\n+ 使用 malloc关键字向堆申请内存空间，在使用完后建议free掉\n+ memset 为新申请的内存做初始化 memset（内存，0，大小）\n+ 主调函数里面的空指针，被调函数中用同级指针分配内存失败需要高级指针来修饰，在主调函数中把指针的地址传入进去\n\n#### 静态变量和全局变量\n\n+ 静态变量：static 关键字修饰\n  + 在程序执行前分配内存\n  + 生命周期为整个程序运行周期\n  + 默认属于内部链接属性，在当前文件夹里使用\n  + 还是跟其他变量的作用域规则一样\n+ 全局变量：\n  + 在C语言中的全局变量在类型前面默认加了一个extern关键字\n  + 属于外部链接属性\n  + extern int g_b；  告诉编译器  其他文件中有一个g_b  在链接的时候去别的文件中找\n\n#### const常量\n\n+ 全局的const 常量 ：\n\n  + 不可修改\t：放在常量区，受到常量区的保护，只具有读的操作\n\n+ 局部的const 常量 （伪常量） ：\n\n  + 不可直接修改，但是可以用指针间接修改\n\n    因为是局部变量 ， 是保存在栈中的，伪常量不可初始化数组\n\n#### 字符串常量\n\n+ char * p = \"hello world\";\n\n+ 相同的字符串常量，被不同的指针所指向，指针的地址值相等\n  + 字符串常量由编译器来决定是否可以修改 \n\n#### 宏函数\n\n+ 在预处理阶段就做了宏的替换\n+ 使用场景：短小且频繁使用的函数，封装为宏函数\n+ 优点：以空间换时间（普通函数的变量需要频繁入栈和出栈）\n+ 注意事项：运算的时候需要保证运算的完整性\n\n#### 函数的调用流程\n\n+ 记录函数的返回地址（在调用完子函数后，能继续执行主函数的后面的代码）\n+ 进栈，参数从左往右进栈\n\n#### 调用惯例\n\n+ 主调函数和被调函数之间需要有一个约定才能正确的调用函数\n\n+ cdecl C语言默认的调用惯例，参数传递从右到左参数入栈，出栈方是函数调用方，名字修饰用下划线加函数名\n\n#### 函数变量传递分析\n\n+ main函数在栈中开辟的内存，所有子函数都能使用\n+ main函数在堆中开辟的空间，所有子函数均可以使用\n\n#### 栈的生长方向\n\n+ 栈底是高地址，栈顶是地地址\n\n#### 内存存储方式\n\n+ 根据大端对齐模式还是小端对齐模式\n+ 大端对齐模式：高位字节数据放在内存低地址处\n+ 小端对齐模式：高位字节数据放在内存高地址\n\n#### 指针强化\n\n+ 指针是一种数据类型，占用内存空间，用来保存地址（任何类型的指针都只占四个字节的内存空间）\n+ 空指针：指向NULL   野指针：指向的内存不是自己申请的\n+ 不能向空指针和野指针指向的内存进行操作，如果操作，程序中断\n\n#### 野指针三种情况\n\n+ 指针没有进行初始化，就进行操作\n+ malloc后free后的指针    解决办法：指向NULL\n+ 指针变量超出了作用域\n+ 空指针可以重复释放，野指针不能重复释放\n\n#### 指针的步长\n\n+ 指针变量+1后跳跃的字节数\n+ 在解引用时候，取出的字节数\n+ 结构体中成员的偏移量 ： 用offsetof（结构体，成员名）宏函数; 需要导入头文件#include<stddef.h>\n\n#### 指针的间接赋值\n\n+ 间接赋值的三大条件：\n  + 两个变量（普通变量或指针变量，形参实参）\n  + 建立关系\n  + 通过*操作指针指向的内存\n\n#### 指针做函数参数\n\n+ 输入特性：主调函数分配内存，被调函数可以使用\n+ 输出特性：被调函数分配内存\n\n\n\n#### 字符串指针强化\n\n+ 注意事项：\n\n  + 字符串结束标志 \\0\n\n  + char str[] ={'a','c','\\0'}   这种需要在后面手动加上\\0结尾\n  + char str[10] = {'s','b'}   这种会自动给你加上\\0结尾\n  + char str = \"hello world\"  也是自动加上\\0    strlen() 不统计\\0   sizeof() 统计\\0\n\n#### 字符串拷贝\n\n+ 第一种：根据下标进行拷贝\n\n  ```c\n  void copyStringMethod1(char *dest,char *source)\n  {\n      int len = strlen(source);\n      for(int i =0;i<len;i++)\n      {\n          dest[i]  = source[i];\n      }\n      dest[len] = '\\0'; //把结束标志进行打上，避免外界数组没有进行初始化而导致乱码\n  }\n  ```\n\n+ 第二种：根据指针进行拷贝\n\n  ```c\n  void copyStringMethod2(char *dest,char *source)\n  {\n      while(*source!='\\0')\n      {\n          *dest = *source;\n          dest++;\n          source++;\n      }\n      *dest = '\\0';\n  }\n  ```\n\n+ 第三种：根据指针的简洁版\n\n  ```c\n  void copyStringMethod3(char *dest,char *source)\n  {\n      while(*dest++ = *source++);//当左值已经为0就不会再进入循环\n  }\n  ```\n\n#### 字符串反转\n\n+ 第一种：根据下标进行反转\n\n  ```c\n  void reverseString(char *str)\n  {\n      int len = strlen(str);\n      int start = 0;  //指向第一个\n      int end = len -1; //指向最后一个\n      while(start <end)\n      {\n          char temp = str[start];\n          str[start] = str[end];\n          str[end] = temp;\n          start++;\n          end--;\n      }\n  }\n  ```\n\n+ 第二种：根据指针进行反转\n\n  ```c\n  void reverseString(char *str)\n  {\n      int len = strlen(str);\n      char *start = str;  //定义一个指针,指向首地址\n      char *end  = str +len-1;  //加上偏移量 指向最后一个\n      while(start<end)\n      {\n          char temp = *start;\n          *start = *end;\n          *end = temp;\n          start++;\n          end--;\n      }\n  }\n  ```\n\n#### 字符串格式化\n\n+ int sprintf(char * str , const char * format,...), 失败返回-1，成功返回格式化字符个数\n\n+ 参数1：格式化的后的目标字符串 参数2：格式化形式  参数3：...  格式化中的参数\n\n  ```c\n  sprintf(buf,\"今天是 %d 年 %d 月 %d 日 \",2023,04,05);\n  ```\n\n+ 字符串拼接\n\n  ```c\n  char str[1024];\n  memset(str, 0, 1024);\n  char str1[] = \"hello world\";\n  char str2[] = \"yzpcode\";\n  sprintf(str, \"%s %s \",str1,str2);\n  ```\n\n#### calloc 和 realloc \n\n\n\n\n\n"},{"title":"springboot项目实战","url":"/2023/03/31/springboot项目实战/","content":"\n\n#### 创建项目和添加依赖\n\n+ **在线创建项目**\n\n  + 地址：https://start.spring.io/\n\n+ **添加依赖**\n\n  + springboot核心包\n\n    ```\n    <dependency>\n          <groupId>org.springframework.boot</groupId>\n          <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n          <groupId>org.springframework.boot</groupId>\n          <artifactId>spring-boot-starter-test</artifactId>\n          <scope>test</scope>\n          <exclusions>\n            <exclusion>\n              <groupId>org.junit.vintage</groupId>\n              <artifactId>junit-vintage-engine</artifactId>\n            </exclusion>\n          </exclusions>\n        </dependency>\n    ```\n\n  + mybatis依赖\n\n    ```\n    <dependency>\n          <groupId>org.mybatis.spring.boot</groupId>\n          <artifactId>mybatis-spring-boot-starter</artifactId>\n          <version>2.1.2</version>\n    </dependency>\n    ```\n\n  + mysql驱动（注意需要去掉runtime，否则会报错）\n\n    ```\n    <dependency>\n          <groupId>mysql</groupId>\n          <artifactId>mysql-connector-java</artifactId>\n    </dependency>\n    ```\n\n  + 通用工具包\n\n    ```\n    <dependency>\n          <groupId>org.apache.commons</groupId>\n          <artifactId>commons-lang3</artifactId>\n          <version>3.12.0</version>\n    </dependency>\n    ```\n\n  + 跨域身份验证解决方案 Json web token包\n\n    ```\n    <!-- JWT相关 -->\n    <dependency>\n          <groupId>io.jsonwebtoken</groupId>\n          <artifactId>jjwt</artifactId>\n          <version>0.7.0</version>\n    </dependency>\n    ```\n\n  + 高性能缓存组件\n\n    ```\n    <!--guava依赖包-->\n    <dependency>\n          <groupId>com.google.guava</groupId>\n          <artifactId>guava</artifactId>\n          <version>19.0</version>\n    </dependency>\n    ```\n\n#### 打通数据库\n\n+ **添加数据库配置**(在``application.properties``)\n\n+ 配置文件中添加)\n\n  ```\n  server.port=8081\n  \n  #==============================数据库相关配置========================================\n  spring.datasource.driver-class-name =com.mysql.cj.jdbc.Driver\n  spring.datasource.url=jdbc:mysql://localhost:3306/online_class_yzpcode?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8&useSSL=false\n  spring.datasource.username=root\n  spring.datasource.password=1234\n  #使用阿里巴巴druid数据源，默认使用自带的\n  #spring.datasource.type =com.alibaba.druid.pool.DruidDataSource\n  #开启控制台打印sql\n  mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl\n  \n  # mybatis 下划线转驼峰配置,两者都可以\n  #mybatis.configuration.mapUnderscoreToCamelCase=true\n  mybatis.configuration.map-underscore-to-camel-case=true\n  #配置扫描\n  mybatis.mapper-locations=classpath:mapper/*.xml\n  #配置xml的结果别名\n  mybatis.type-aliases-package=xyz.yzpcode.online_class.domain\n  ```\n\n#### 开启热部署和开发统一JSON数据格式工具类\n\n+ **热部署设置**\n\n  ```\n  <dependency>  \n           <groupId>org.springframework.boot</groupId>  \n           <artifactId>spring-boot-devtools</artifactId>  \n           <optional>true</optional>  \n    </dependency>\n    \n    \n    <build>\n          <plugins>\n              <plugin>\n                  <groupId>org.springframework.boot</groupId>\n                  <artifactId>spring-boot-maven-plugin</artifactId>\n                  <configuration>\n                      <fork>true</fork><!--必须添加这个配置-->\n                  </configuration>\n              </plugin>\n          </plugins>\n      </build>\n  ```\n\n  需要在``idea``中``compiler``开启 ``build project automatically`` 然后按住``shift+Ctrl+alt+/ ``选择``registry ``选择``auto when app running``然后重启``idea``即可\n\n+ **JsonData工具类**\n\n  ```\n  public class JsonData {\n  \n      /**\n       * 状态码  0表示成功   1表示处理中  -1表示失败\n       */\n      private Integer code;\n  \n      /**\n       * 业务数据\n       */\n      private Object data;\n  \n      /**\n       * 信息显示\n       */\n      private String msg;\n  \n      JsonData(){}\n  \n      JsonData(Integer code,Object data,String msg){\n          this.code = code;\n          this.data = data;\n          this.msg  = msg;\n      }\n  \n      /**\n       * 成功   不返回数据\n       * @return\n       */\n      public static JsonData buildSuccess(){\n          return new JsonData(0,null,null);\n      }\n  \n      /**\n       * 成功   返回数据\n       * @param data\n       * @return\n       */\n      public static JsonData buildSuccess(Object data){\n          return new JsonData(0,data,null);\n      }\n  \n      /**\n       * 失败    固定状态码\n       * @param msg\n       * @return\n       */\n      public static JsonData buildError(String msg){\n          return new JsonData(-1,null,msg);\n      }\n  \n      /**\n       * 失败   自定义状态码\n       * @param code\n       * @param msg\n       * @return\n       */\n      public static JsonData buildError(Integer code,String msg){\n          return new JsonData(code,null,msg);\n      }\n  \n      public Integer getCode() {\n          return code;\n      }\n  \n      public void setCode(Integer code) {\n          this.code = code;\n      }\n  \n      public Object getData() {\n          return data;\n      }\n  \n      public void setData(Object data) {\n          this.data = data;\n      }\n  \n      public String getMsg() {\n          return msg;\n      }\n  \n      public void setMsg(String msg) {\n          this.msg = msg;\n      }\n  }\n  ```\n\n#### 自定义异常\n\n+ 自定义异常  继承RuntimeException\n\n  ```\n  /**\n   * 自定义全局异常\n   */\n  public class YZPException  extends RuntimeException{\n  \n      private Integer code;\n  \n      private String msg;\n  \n      public YZPException(Integer code,String msg){\n          this.code = code;\n          this.msg  = msg;\n      }\n  \n      public Integer getCode() {\n          return code;\n      }\n  \n      public void setCode(Integer code) {\n          this.code = code;\n      }\n  \n      public String getMsg() {\n          return msg;\n      }\n  \n      public void setMsg(String msg) {\n          this.msg = msg;\n      }\n  }\n  ```\n\n+ 开发异常处理器 ExceptionHandle\n\n  ```\n  /**\n   * 异常处理类\n   */\n  @ControllerAdvice\n  public class CustomExceptionHandler {\n  \n      private final static Logger logger =  LoggerFactory.getLogger(CustomExceptionHandler.class);\n  \n      @ExceptionHandler(value = Exception.class)\n      @ResponseBody\n      public JsonData handle(Exception e){\n          logger.error(\"[ 系统出错 ] \",e);\n          if( e instanceof YZPException){\n  \n              YZPException yzpException = (YZPException) e;\n              return JsonData.buildError(yzpException.getCode(),yzpException.getMsg());\n          }else{\n              return JsonData.buildError(\"全局异常，未知错误\");\n          }\n      }\n  }\n  ```\n\n#### 用户注册接口\n\n* **保证注册手机号的唯一性**\n\n  + 可以在数据库建表的时候将phone字段添加唯一约束unique\n  + 可以在用户注册的时候，根据前端传来的手机号在数据库中查找，保证唯一\n\n* **MD5 密码加密**\n\n  + 建一个工具类(将代码拷过去就能直接使用)\n\n    ```\n    public static String MD5(String data)  {\n            try {\n                java.security.MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                byte[] array = md.digest(data.getBytes(\"UTF-8\"));\n                StringBuilder sb = new StringBuilder();\n                for (byte item : array) {\n                    sb.append(Integer.toHexString((item & 0xFF) | 0x100).substring(1, 3));\n                }\n    \n                return sb.toString().toUpperCase();\n            } catch (Exception exception) {\n            }\n            return null;\n    \n    }\n    ```\n\n#### 用户登录接口\n\n+ JWT工具类开发\n\n  + pom文件添加依赖\n\n    ~~~\n    <!-- JWT相关 -->\n        <dependency>\n          <groupId>io.jsonwebtoken</groupId>\n          <artifactId>jjwt</artifactId>\n          <version>0.7.0</version>\n        </dependency>\n    ~~~\n\n  + 封装生产token方法\n\n    ~~~\n    /**\n         * 根据用户信息，生成令牌\n         * @param user\n         * @return\n         */\n        public static String geneJsonWebToken(User user){\n            String token = Jwts.builder().setSubject(SUBJECT)\n                    .claim(\"head_img\",user.getHeadImg())\n                    .claim(\"id\",user.getId())\n                    .claim(\"name\",user.getName())\n                    .setIssuedAt(new Date())\n                    .setExpiration(new Date(System.currentTimeMillis()+EXPIRE))\n                    .signWith(SignatureAlgorithm.HS256,SECRET).compact();\n            token = TOKEN_PREFIX + token;\n            return token;\n        }\n    ~~~\n\n  + 封装校验token方法\n\n    ```\n     /**\n         * 校验 token 方法\n         * @param token\n         * @return\n         */\n        public static Claims checkJWT(String token){\n          try  {\n              final Claims claims = Jwts.parser().setSigningKey(SECRET).parseClaimsJws(token.replace(TOKEN_PREFIX, \"\")).getBody();\n              return claims;\n          }catch (Exception e){\n              return null;\n          }\n        }\n    ```\n\n   + 工具类\n\n     ~~~\n     /**\n      * JWT工具类\n      * 1.生成的token，可以通过 base64 解密出明文信息\n      * 2.base64 解密出的明文，再次进行编码，秘钥会失效\n      * 3.无法作废以颁布的 token ，除非修改秘钥\n      */\n     public class JWTUtils {\n         /**\n          * 过期时间，一周\n          */\n         private static final long EXPIRE = 60000 *60 *24 *7;\n     \n         /**\n          * 加密秘钥\n          */\n         private static final String SECRET = \"yzpcode.xyz2644\";\n     \n         /**\n          * 令牌前缀\n          */\n         private static final String TOKEN_PREFIX = \"yzpcode\";\n     \n         /**\n          * subject\n          */\n         private static final String SUBJECT = \"yzpcode\";\n     \n         /**\n          * 根据用户信息，生成令牌\n          * @param user\n          * @return\n          */\n         public static String geneJsonWebToken(User user){\n             String token = Jwts.builder().setSubject(SUBJECT)\n                     .claim(\"head_img\",user.getHeadImg())\n                     .claim(\"id\",user.getId())\n                     .claim(\"name\",user.getName())\n                     .setIssuedAt(new Date())\n                     .setExpiration(new Date(System.currentTimeMillis()+EXPIRE))\n                     .signWith(SignatureAlgorithm.HS256,SECRET).compact();\n             token = TOKEN_PREFIX + token;\n             return token;\n         }\n     \n         /**\n          * 校验 token 方法\n          * @param token\n          * @return\n          */\n         public static Claims checkJWT(String token){\n           try  {\n               final Claims claims = Jwts.parser().setSigningKey(SECRET)\n               .parseClaimsJws(token.replace(TOKEN_PREFIX, \"\")).getBody();\n               return claims;\n           }catch (Exception e){\n               return null;\n           }\n         }\n     }\n     ~~~\n\n+ 登录拦截器\n\n  拦截器(``interceptor``)是对表现层(``controller``)之前和之后进行数据处理的。\n\n  实现一个拦截器需要实现``HandlerInterceptor接口``，然后重写里面的``preHandle方法``，这个方法是在进入``controller``之前，``postHandle``是对之后进行处理，在``postHanle``方法里面需要``return false``，``afterCompletion``是对整体完成之后处理（基本不使用），``interceptor``的执行顺序是链式的\n\n  ```\n  /**\n   * 登录拦截器\n   */\n  public class LoginInterceptor implements HandlerInterceptor {\n  \n      /**\n       * 进入到 controller之前的方法\n       * @param request\n       * @param response\n       * @param handler\n       * @return\n       * @throws Exception\n       */\n      @Override\n      public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n  \n          try {\n              String accessToken = request.getHeader(\"token\");\n  \n              if (accessToken == null) {\n                  accessToken = request.getParameter(\"token\");\n              }\n              if (StringUtils.isNotBlank(accessToken)) {\n                  Claims claims = JWTUtils.checkJWT(accessToken);\n                  if (claims == null) {\n                      //登录过期，重新登录\n                      sendJsonMessage(response, JsonData.buildError(\"登录过期，请重新登录\"));\n                      return false;\n                  }\n                  Integer id = (Integer) claims.get(\"id\");\n                  String name = (String) claims.get(\"name\");\n  \n                  request.setAttribute(\"user_id\", id);\n                  request.setAttribute(\"name\", name);\n                  return true;\n              }\n          }catch (Exception e){}\n  \n          sendJsonMessage(response, JsonData.buildError(\"登录过期，请重新登录\"));\n          return false;\n  \n      }\n      /**\n       * 响应 JSON 数据给前端\n       * @param response\n       * @param obj\n       */\n      public static void sendJsonMessage(HttpServletResponse response,Object obj){\n          try{\n              ObjectMapper objectMapper = new ObjectMapper();\n              response.setContentType(\"application/json; charset=utf-8\");\n              PrintWriter writer = response.getWriter();\n              writer.print(objectMapper.writeValueAsString(obj));\n              writer.close();\n              response.flushBuffer();\n          }catch (Exception e){\n              e.printStackTrace();\n          }\n      }\n  \n      @Override\n      public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n  \n      }\n  \n      @Override\n      public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n  \n      }\n  }\n  ```\n\n#### Guava缓存\n\n+ 添加依赖\n\n  ```\n  <dependency>\n  \t<groupId>com.google.guava</groupId>\n  \t<artifactId>guava</artifactId>\n  \t<version>19.0</version>\n  </dependency>\n  ```\n\n+ 工具类\n\n  ```\n  @Component\n  public class BaseCache {\n  \n      private Cache<String,Object> tenMinuteCache = CacheBuilder.newBuilder()\n              //设置缓存初始大小，需要合理设置\n              .initialCapacity(10)\n              //最大值\n              .maximumSize(100)\n              //并发数设置\n              .concurrencyLevel(5)\n              //缓存过期时间，写入后10分钟过期\n              .expireAfterWrite(600, TimeUnit.SECONDS)\n              //统计缓存命中率\n              .recordStats()\n              .build();\n  \n      private Cache<String,Object> oneHourCache = CacheBuilder.newBuilder()\n              //设置缓存初始大小，需要合理设置\n              .initialCapacity(10)\n              //最大值\n              .maximumSize(100)\n              //并发数设置\n              .concurrencyLevel(5)\n              //缓存过期时间，写入后10分钟过期\n              .expireAfterWrite(3600, TimeUnit.SECONDS)\n              //统计缓存命中率\n              .recordStats()\n              .build();\n  \n      public Cache<String, Object> getOneHourCache() {\n          return oneHourCache;\n      }\n  \n      public void setOneHourCache(Cache<String, Object> oneHourCache) {\n          this.oneHourCache = oneHourCache;\n      }\n  \n      public Cache<String, Object> getTenMinuteCache() {\n          return tenMinuteCache;\n      }\n  \n      public void setTenMinuteCache(Cache<String, Object> tenMinuteCache) {\n          this.tenMinuteCache = tenMinuteCache;\n      }\n  }\n  ```\n\n\n#### Redis\n\n+ **自定义序列化和反序列化机制配置**\n\n  ```java\n  @Configuration\n  public class RedisTemplateConfiguration {\n  \n      /**\n       * @param redisConnectionFactory\n       * @return\n       */\n      @Bean\n      public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {\n  \n          RedisTemplate<Object, Object> redisTemplate = new RedisTemplate<>();\n          redisTemplate.setConnectionFactory(redisConnectionFactory);\n          // 使用Jackson2JsonRedisSerialize 替换默认序列化\n          Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\n  \n          ObjectMapper objectMapper = new ObjectMapper();\n          objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n          jackson2JsonRedisSerializer.setObjectMapper(objectMapper);\n  \n          // 设置key和value的序列化规则\n          redisTemplate.setKeySerializer(new StringRedisSerializer());\n          redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);\n  \n          // 设置hashKey和hashValue的序列化规则\n          redisTemplate.setHashKeySerializer(new StringRedisSerializer());\n          redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);\n  \n          // 设置支持事物\n          //redisTemplate.setEnableTransactionSupport(true);\n  \n          redisTemplate.afterPropertiesSet();\n  \n          return redisTemplate;\n      }\n  \n  }\n  ```\n\n  \n\n  ","tags":["Java"]},{"title":"最大数","url":"/2023/01/01/最大数/","content":"#### 最大数\n\n+ 题目：\n\n  ![](https://picgo-1309496466.cos.ap-chongqing.myqcloud.com/pic/%E6%9C%80%E5%A4%A7%E6%95%B0.png)\n\n+ 题解：最大数就是将最大的组成放在前面，如示例2里面的``3和30比较，330和303，就是330更大，所以元素3在30之前``，将数字数组中的对应元素转为字符串数组中，然后用``compareTo()``方法进行比较，它是从头开始比较字符串对应的``AscII码``值，如果第一个字符相等，就比较后面一个，然后我们用快速排序方法``Arrays.sort()``的``lambda表达式``方式，具体的``Arrays.sort()中的lambda表达式``讲解[](https://blog.csdn.net/qq_41030039/article/details/100176410)\n\n+ 代码：\n\n  ```java\n  class MyAnswer{\n      public String largestNumber(int []nums){\n          int n = nums.length;\n          String[] array = new String[n];\n          for(int i=0;i<n;i++){\n              array[i] = String.valueOf(nums[i]);\n          }\n          //a.concat(b)方法是将两个字符串拼接在一起\n          Arrays.sort(array,(a,b)->b.concat(a).compareTo(a.concat(b)));\n          //如果第一个元素就是0；那么后面的都比零小，所以直接返回0\n          if(array[0].equals(\"0\")){\n              return \"0\";\n          }\n          StringBuilder sb = new StringBuilder();\n          for(int i=0;i<n;i++){\n              sb.append(array[i]);\n          }\n          return sb.toString();\n      }\n  }\n  ```\n\n  ","tags":["力扣刷题"]},{"title":"买卖股票的最佳时机","url":"/2022/12/28/买卖股票的最佳时机/","content":"#### 买卖股票的最佳时机||\n\n+ 题目：\n\n  ![](https://picgo-1309496466.cos.ap-chongqing.myqcloud.com/pic/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA2.png)\n\n+ 题解：\n\n  从数组的最前面开始遍历数组，利用双指针，当前面一个数字比后面一个数字小的时候，就让前面的数字进行购买，然后再从后面找一个最大的数字，把他比作卖出。更好理解的就是：如果把他比作为单调函数的话，一开始是单调递减的话，那么就当开始递增的那个点就肯定是最小的，那个点就购买，然后再递减了的那个点就是局部最大，所以那个点就卖出，这样两个点的差值就最大。\n\n  ![](https://picgo-1309496466.cos.ap-chongqing.myqcloud.com/pic/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E9%A2%98%E8%A7%A3.png)\n\n+ 代码:\n\n  ```java\n  class MyAnswer{\n       public int maxProfit(int[] prices) {\n           if(prices==null||prices.length<2){\n               return 0;\n           }\n           int sum =0, index=0,n=prices.length;\n           while(index<n){\n               //当一直递减就找到最小的值\n               while(index<n-1 && prices[index]>=prices[index+1]){\n                   index++;\n               }\n               int min = prices[index];\n               //找到递增的最大值\n               while(index<n-1 && prices[index]<=prices[index+1]){\n                   index++;\n               }\n               sum += prices[index++]-min;\n           }\n           return sum;\n       }\n  }\n  ```\n\n  ","tags":["力扣刷题"]},{"title":"多线程并发编程","url":"/2022/12/07/多线程并发编程/","content":"#### 什么是并发编程\n\n+ 串行和并行的区别：并行可以缩短整个流程的时间\n+ 并发编程的目的:从某种程度上加快程序响应的速度（耗时任务，web服务器），简化异步事件的处理，让程序充分利用计算机资源\n+ 什么时候适合使用并发编程：\n  + 任务会阻塞线程，导致之后的代码不能执行：比如一边从文件中读取，一边进行大量的计算的情况\n  + 任务执行时间过长，可以划分为分工明确的子任务：比如分段下载\n  + 任务间断性执行：日志打印\n  + 任务本身需要协作执行：比如生产者消费者问题\n\n#### 并发编程挑战频繁的上下文切换\n\n+ 上下文的频繁切换，会带来一定的性能开销\n+ 如何减少上下文切换的开销？\n  + 无锁并发编程\n    + 无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的id按照hash算法取模分段，不同的线程处理不同分段的数据\n  + CAS\n    + Java的Atomic包使用的CAS算法来更新数据，而不需要加锁\n  + 使用最少的线程\n    + 避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态\n  + 协程（go语言使用的多，就Java很少使用）\n\n#### 并发编程挑战死锁\n\n+  在cmd控制台输入jconsole可以查看是否出现死锁\n\n#### 并发编程挑战线程安全\n\n+ ~~~java\n  public class UnSafeThread{\n      private static int num=0;\n      private static CountDownLatch cdl=new CountDownLatch(10);\n      \n      \n      public static void inCreate(){\n         num++;\n      }\n      public static void main(String []args){\n      for(int i=0;i<10;i++){\n          new Thread(()->{\n            for(int j=0;j<100;j++){\n            inCreate();\n            Thread.sleep(10)://会抛异常需要捕获\n            }\n            //每个线程执行完成之后，调用countdownlatch\n            cdl.counyDown();\n  }).start();\n      }\n      while(true){\n        if(cdl.getCount()==0){\n           System.out.println(num);\n           break;\n        }\n      }\n      }\n  \n  }\n  ~~~\n\n\n\n#### 并发编程挑战资源限制\n\n+ 硬件资源\n  + 带宽的上传和下载熟读，硬盘的读写速度和CPU的处理速度\n+ 软件资源\n  + 数据库连接 500个连接，1000个线程查询，并不会因此加快，socket（最大打开数）\n\n#### 线程的基础知识\n\n+ 进程和线程的区别\n\n  + 进程：是系统进行分配和管理资源的基本单位\n  + 线程：进程的一个执行单元，是进程内调度的实体，是CPU调度和分配和分派的基本单位，是比进程更小的独立运行的基本单位。线程也被称为轻量级进程，线程是程序执行的最小单位\n  + 一个程序至少一个进程，一个进程至少一个线程\n  + 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段，堆栈段和数据段，这种操作十分昂贵\n  + 而线程是共享进程中的数据的 ，使用相同的地址空间，因此cpu切换一个进程的花费远比进程要小很多 ，同时创建一个线程的开销也比进程要小很多\n  + 线程之间的通信更方便，同一个进程下的先后才能共享全局变量，静态变量等数据，而进程之间的通信需要以通信的方式进行\n  + 如何处理好同步与互斥是编写多线程程序的难点\n  + 多进程程序更健壮，进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其他的进程产生影响，而线程只是进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间，没有独立的地址空间，所以可能一个线程出现问题，进而导致整个程序出现问题\n\n+ 线程的状态及其相互转换\n\n  + 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法\n\n  + 运行(runnable)：chuy7u可运行状态的线程在JVM中执行，但他可能正在等待来自操作系统的其他资源，例如处理器\n\n  + 阻塞(blocked)：线程阻塞与synchronized锁，等待获取synchronized锁的状态\n\n  + 等待(waiting)：Obiect.wait(),join(),LockSupport.park(),进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）\n\n  + 超时等待(time_waiting):\n\n    Object.wait(long),Thread.join(),LockSupport.parkNanos(),LockSupport.parkUntil，该状态不同于waiting，他可以在指定的时间内自行返回\n\n  + 终止(terminated)：表示该线程已经执行完毕\n\n  + 他们之间的相互转换\n\n    ![](https://picgo-1309496466.cos.ap-chongqing.myqcloud.com/pic/image-20220913094152576.png)\n\n+ 创建线程上\n\n  + 第一种是直接继承Thread，并重写父类的run方法\n\n    ```java\n    public class MyThread extends Thread{\n       @Override//重写run方法\n       public void run(){\n          System.out.println(Thread.currentThread.getName());\n       }\n       \n       public static void main(String []args){\n         MyThread myThread=new MyThread();\n         mythread.setName(\"余贞佩真帅\");\n         myThread.start();\n         }\n    }\n    ```\n\n  + ()第二种直接实现Runable接口，并实现run方法\n\n    ```\n    public class MyRunable implements Runable{\n       @Override//重写run方法\n       public void run(){\n         System.out.println(Thread.currentThread().getName());\n       }\n       \n       public static void main(String []args){\n          Thread thread=new Thread(new MyRunable());\n          thread.setName(\"余贞佩是帅哥\");\n          thread.start();\n          \n          \n          //不使用thread.start而直接使用run的话,不会启动线程，只会启动原本的线程，在实际开发中需要用thread.start()\n          thread.run();\n       }\n       \n    }\n    ```\n\n  + 实际开发中，选第二种，因为Java只支持单继承，支持多接口，还可以增加程序的健壮性，代码可以共享，代码和数据相对独立\n\n+ 创建线程下\n\n  + 使用匿名内部类的方式（也是runnable）\n\n    ```\n    public class MyThread{\n       public static void main(String []args){\n       Thread thread=new Thread(new Runnable(){\n         @Override\n          public void run(){\n          System.out.println(\"余贞佩真帅\");\n       }\n       );\n          \n    }\n       }\n    }\n    ```\n\n   + 使用Lambda\n\n     ```\n     public class Lambda{\n         public static void main(String []args){\n         new Thread(()->{\n            System.out.println(\"余贞佩真帅\");\n         }).start();\n         }\n     }\n     ```\n\n    + 使用线程池的方法ExecutorService\n\n      ```\n      public class ThreadPool{\n         public static void main(String []args){\n         ExecutorService executorSevice=Executor.newSingleThreadExecutor();\n         executorService.execute(()->{\n         System.out.println(\"余贞佩真帅\");\n       \n         });\n           }\n      }\n      ```\n\n+ 线程的挂起和恢复\n\n  + 什么是挂起线程\n\n    + 线程的挂起操作实质上就是使线程进入“非可执行”状态，在这个状态下cpu不会分给线程时间片，进入这个状态可以用来暂停一个线程的运行，在线程挂起后，可以通过重新唤醒线程来恢复运行\n\n  + 为什么要挂起线程\n\n    + cpu分配的时间片非常短，同时也非常珍贵，避免资源的浪费\n\n  + 如何挂起线程\n\n    + thread.suspend();//挂起   不会释放线程所占用的资源，如果使用该方法将某个线程挂起，则可能使其他等待资源的线程死锁\n\n    + thread.resume();//唤醒       脱离了suspend就无法使用，无法单独使用。这两个方法不用了\n\n    + 可以使用的方法\n\n      + wait();//暂停执行，放弃已获得的锁，进入等待状态\n\n      + notify();//随机唤醒一个在等待锁的进程\n\n      + notifyAll();//唤醒所有在等待锁的进程，自行抢占cpu资源\n\n      + ```\n        public class WaitDemo{\n             private  static Object waObject=new Object();\n             @Override\n             public void run(){\n             //特有资源\n             synchronized(waObject){\n              System.out.println(\"yuzhenpe\"+\"余贞佩\");\n              waObject.wait();//这里需要捕获异常\n             }\n             System.out.println(\"太帅了\");\n        }\n           public static void main(String []args){\n           Thread thread=new Thread(new WaitDemo(),name\"线程名字\");\n           thread.start();\n           Thread.sleep(1000L)//休眠一秒钟\n           synchronized(waObject){\n           waObject.notify();\n        }\n           }\n        }\n        \n        注意：在使用的时候需要注意两个都需要持有锁，并且都需要是锁住的是相同的对象\n        ```\n\n  + 什么时候适合使用挂起线程\n\n    我等的船还不来（等待某些未就绪的资源，让出时间片给其他的线程，直到notify唤醒）\n\n+ 线程的中断操作\n\n  + stop();//已经废弃的方法，不要使用。因为一调用，线程就立刻停止，此时有可能引发相应的线性安全性问题\n\n  + interrupt();方法\n\n    ```\n    public class InterruptDemo implements  Runnable{\n        @Override\n        public void run(){\n          while(!Thread.currentThread().isInterrupt()){//判断是否被interrupt方法标记了中断线程\n              System.out.println(\"余贞佩真帅\");\n          }\n        }\n        \n        public static void main(String []args){\n           Thread thread=new Thread(new InterruptDemo());\n           thread.start();\n           Thread.sleep(3000L);\n           thread.interrupt();//调用这个方法会给线程标记中断线程的标记\n        }\n    \n    }\n    ```\n\n  + 通过volatile来定义变量来实现\n\n    ```\n    public class MyInterruptDemo imlements Runnable{\n        private static volatile boolean flag=ture;//这里一定需要加volatile关键字\n        @Override\n        public void run(){\n        while(flag){\n          System.out.println(\"余贞佩真帅\");\n        }\n        }\n        public static void main(String []args){\n          Thread thread=new Thread(new MyInterruptDemo());\n          thread.start();\n          Thread.sleep(1000L);\n          flag=false;//通过修改volatile修饰的变量来控制退出循环中断线程\n        }\n        \n    }\n    ```\n\n+ 线程的优先级\n\n  + 线程的优先级会告诉程序该线程的重要程度。如果大量线程都被堵塞，都在等候运行，那么程序会尽可能的优先运行优先级高的线程。不代表优先级低的线程不会被运行，只是被运行的机会比较少\n\n  + 设置线程的优先级\n\n    ```\n    public class PriorityDemo{\n         \n         public static void main(String []args){\n           \n           Thread thread1=new Thread(()->{\n               System.out.println(Thread.currentThread().getName()+\"余贞佩真帅\");\n           },\"线程1\");\n           Thread thread2=new Thread(()->{\n               System.out.println(Thread.currentThread().getName()+\"余贞佩真帅\");\n           },\"线程2\");\n           thread1.setPriority(MIN);//设置为1到10之间的整数，Priority提供了1,5,10三种（建议）\n           thread2.setPrioity(MAX);\n           thread1.start();\n           thread2.start();\n         }\n    }\n    ```\n\n  + 线程优先级可以设置为1-10的任意数值，Thread类定义了三个数值表示线程优先级，MIN_PRIORity(1);NORM_PRIORITY(5);MAX_PRIORITY(10);一般情况推荐使用这三种，不要自行设置数值\n\n  + 不同的平台对线程优先级的支持不同\n\n    + 编程的时候不要过度依赖线程优先级，如果程序的运行是否正确取决于你设置的优先级是否按所设置的优先级运行，那这样的程序不正确\n\n  + 任务是快速处理就设置为优先级高\n\n  + 任务是慢慢处理就设置为优先级低（但是得保证不影响程序运行）\n\n+ 守护线程\n\n  + 线程分类：用户线程，守护线程\n\n  + 守护线程\n\n    + 任何一个守护线程都是用户线程的守护者，只要有用户线程活着，守护线程就活着。在JVM实例中最后一个非守护线程结束时，也随JVM一起退出\n    + 作用：JVM垃圾清理线程\n\n  + 在开发中少使用守护线程，因为其不可控，容易在运行到一半的时候随着用户线程的消失而消失，如果一定要使用守护线程，也不要在守护线程进行读写计算等逻辑\n\n  + 在Java中设置守护线程\n\n    ```\n    public static void main(String []args){\n          Thread thread=new Thread(new Yzp());\n          thread.setDaemo(ture);//系统默认false\n          thread.start();\n          //注意，设置为守护线程一定需要在thread.start()之前，在之后不会被设置为守护线程\n    }\n    ```\n\n\n#### 线程安全\n\n+ 线程安全性问题\n\n  + 什么是线程安全性\n    + 当多个线程访问某个类，不管运行环境如何调度或线程如何交替执行，并且在主调代码中不需要任何额外的同步或者协同，这个 类都能做出正确的行为，那么这个类是线程安全的\n  + 什么是线程不安全\n    + 多线程并发访问的时候，得不到正确的结果\n\n+ 从字节码剖析线程不安全操作\n\n  + 例子：num++不是原子性操作，被拆分为多个步骤，在多线程并发执行的时候，因为cpu的调度，多线程快速切换，有可能多个线程在同一个时刻读取了同一个num的值，然后对相同的num值进行++，得不到正确的结果，导致线程安全性问题\n\n+ 原子性操作\n\n  + 什么是原子性操作\n\n    一个操作或多个操作在执行的过程中不会被任何因素阻断，要么都不执行\n\n  + 如何把非原子性操作变为原子性操作\n\n    + volatile关键字仅仅保证可见性，并不能保证原子性\n\n    + synchronized关键字，可以使操作具有原子性\n\n + synchronized关键字\n\n   + 内置锁\n\n     每一个Java对象，都可以用做一个实现同步的锁，这些锁称为内置锁。线程进入同步代码块或者方法的时候会自动获得该锁，在退出同步代码块或者方法的时候会释放该锁\n\n     获得内置锁的唯一途径是进入这个锁所保护的同步代码块或方法\n\n   + 互斥锁\n\n     + 内置锁是一个互斥锁，这就意味着最多只有一个线程可以获得这个锁，当线程a尝试获得线程b所持有的锁的时候，线程a会进入堵塞或者等待状态，直到线程b释放这个锁\n     + 如果线程b一直不释放锁，那么线程a就会一直等待或者堵塞\n\n   + 修饰普通方法：锁住的是类的实例`public synchronized void test()`\n\n   + 修饰静态方法：锁住的是整个类（最好不要用）`public static synchronized`staticTest()\n\n   + 修饰代码块：锁住的是一个对象。锁住的是synchronized括号后面的那个对象\n\n     + ```\n       public void yzp(){\n          synchronized(对象){\n          \n          }\n       }\n       ```\n\n + volatile关键字\n\n   + 能且仅能修饰变量\n   + 保证变量的可见性，但是不能保证原子性\n   + 禁止指令重排序\n   + 比如：A,B两个线程同时读取被volatile修饰的对象，A线程的读取过后修改了变量的值，修改的值对于B线程来说是可见的\n   + 使用场景\n     + 作为线程的开关\n     + 单例，修饰对象的实例，禁止指令重排序\n\n + 单例与线程安全\n\n   + 饿汉式（本身线程安全）不需要加锁\n\n     在类加载的时候就已经实例化，不管用不用的到。如果该类占内存大，且后面也用不到，就白白浪费了资源\n\n     + 在idea有一个Singleton可以帮我们创建\n\n   + 懒汉式（最简单的写法是非线程安全的）\n\n     在需要的时候在进行实例化\n\n     ```\n     public class LazySingleton{\n           praivate static volatile LazySingle=null;//在这里需要volatile关键字来禁止指令重排序\n           private LazySingle(){//私有化\n     }\n          public static LazySingleton getInstance(){\n          //判断实例化是否为空，为空则实例化对象，否者直接返回\n          if(null==lazySingle){\n            Thread.sleep();//这里需要抛出异常\n            synchronized(LazySingle.class){\n              if(null==lazySingle){\n               lazysinglr=new LazySingle();\n     }\n            }\n          }\n          return lazySingle;\n          \n          }\n     }\n     这样是线程安全的\n     ```\n\n + 如何避免线程安全性问题\n\n   + 产生线程安全性的原因\n\n     + 多线程环境\n     + 多个线程操作同一个共享资源\n     + 对该共享资进行了非原子性操作\n\n   + 如何避免\n\n     打破三个成因其中一个\n\n     + 将多线程变为单线程（必要的代码，加锁访问）\n     + 不共享资源（ThreadLocal,不共享，或者将操作变为无状态，将变量变为不可变变量（final））\n     + 将非原子性操作变为原子性操作（加锁，使用jdk自带的原子性操作的类，juc提供的相应的并发工具类）\n\n#### 锁\n\n+ 锁的分类\n\n  <img src=\"https://picgo-1309496466.cos.ap-chongqing.myqcloud.com/pic/image-20220915162626728.png\" style=\"zoom: 50%;\" />\n\n  <img src=\"https://picgo-1309496466.cos.ap-chongqing.myqcloud.com/pic/image-20220915162807317.png\" style=\"zoom:50%;\" />\n\n+ 深入理解Lock接口\n\n  + Lock的使用\n\n    ```\n    private static Lock lock=new ReeentrantLock();\n    public static void inCreate(){\n       lock.lock();//在需要加锁的方法内加锁\n       num++;\n       lock.unlock();//需要手动的解锁\n    }\n    ```\n\n  + lock和synchronized的区别\n\n    + lock需要手动的加锁和解锁，synchronized则是托管给jvm去实现\n    + synchronized的机制是悲观锁，每个线程都是独占锁，独占锁意味着其他的锁只能依靠堵塞来等待释放锁\n    + lock是乐观锁，实现CAS操作\n    + 而synchronized现在与lock的性能差不多\n\n+ 实现自己的锁（具有重入的功能）\n\n  + ```\n    public class MyLock implements Lock{\n        \n        private boolean isHoldLock=false;\n        private Thread holdLockThread=null;\n        private int reentryCount=0;\n    \n        //重写Lock类的方法\n        //在同一时刻有且只有一个线程能获的锁，其他的线程需要等待这个线程释放锁后才能获得锁\n        @Override\n        public synchronized void lock(){//需要用到wait和notify方法所以需要在方法上面上锁\n            if(isHoldLock&&holdLockThread!=Thread.currentThread()){\n                  wait();//这里需要抛出异常\n            }\n            holdLockThread=Thread.currentThread();\n            isHoldLock=true;  \n        }\n        @Override\n        public synchronized void unlock(){\n        //判断当前线程是否持有锁，如果是，重入数就减一，不是就不做处理\n           if(Thread.currentThread==holdLockThread){\n               reentryCount--;\n              if(reentryCount==0){\n               notify();\n               isHoldLock=false;\n              }\n          }\n        }\n    \n    }\n    ```\n\n+ AbstractQueuedSynchronizer浅析\n\n+ ReentrantLock源码（new的时候带参数TRUE就是公平锁，不带参就是非公平锁）\n\n+ ReentrantLock公平锁和非公平锁的区别\n\n  + 公平锁遵守排队规则，比如在公共厕所上厕锁，只要前面的在排队，那么刚进来的就会老老实实的排队\n  + 非公平锁有点像流氓，只要当前有空的坑位，他就会直接霸占，不管后面排队的人。只要有机会就会抢占资源\n\n+ 非公平锁的弊端\n\n  + 可能导致后面等待的线程等不到相应的cpu资源从而引起线程饥饿\n\n+ 掌控线程的执行顺序之多线程Debug\n\n  + 在使用ReentrantLock类的时候释放锁的操作需要放在异常finally里面\n  + \n\n","tags":["并发编程"],"categories":["Java"]},{"title":"HTML和CSS基础","url":"/2022/12/06/HTML和CSS基础/","content":"## HTML\n\n##### 基础知识\n\n* 常见的几个标签：\n\n  ```\n  <meta>标签是放在<head>下的,没有结束标签为自结束标签\n  <a herf>标签是放在<body>下的，定义一个超链接，用于跳转网站\n  &nbsp;  这个是在网页中加空格，要添加多少空格就写多少次\n  <link>标签是放在<title>下的，用于链接外部的样式表\n  <hr>标签是放在<body>下的，加一条横线区分上半段和下半段\n  <img>标签是放在<body>下的，在网页中添加图片，其中src后面是放图片的地址，alt后面是图片的标签\n  <input>标签是放在<body>标签下的，创建一个输入框\n  ```\n\n* 注释\n\n  + 当代码复杂度大时，便于解释说明代码的含义\n  + 注释暂时用不到的代码片段\n  + 注释不能嵌套，否则网页中会渲染出-->\n\n* 语义化标签\n\n  ```\n  <title>网页标签是网站和标签的名字\n  <h1>~<h6>：网页内容的标题(最好只使用一个h1)一般使用h1~h6\n  <p>标签是换行的操作，相当于Word里面的回车换行\n  <strong>强调加粗度字体\n  下面几种很少用到：\n  头部元素：header\n  导航元素：nav\n  主要内容：main\n  ```\n\n  + 优化代码结构：在页面没有css的情况下，也能够呈现出很好的内容结构\n  + 有利于SEO：标签确定关键字的权重，因此可以增加搜索相关权重，使网站搜索结果中的排列顺序\n\n##### 具体知识\n\n* **a标签的用法**\n\n  ```\n  跳转：<a href=\"网站地址\">网站名字</a>\n  锚点：<a href=\"#xxx\">网页中的点击名字</a>（用于点击网页跳转）\n  点击网页跳转并打开另一个浏览器界面：<a href=\"网站地址\" target=\"blank\">网页中的点击名</a>\n  ```\n\n* target属性\n\n  + blank：打开新的浏览器标签\n\n* 路径\n\n  根据资源的类型判断，一般站外资源用绝对路径，站内资源用相对路径\n\n  + 绝对路径\n\n    `https://xdclass.net`\n\n  + 相对路径\n\n    ```\n    ./ 代表当前目录\n    ../ 代表的上一级目录\n    内部的资源也可以用绝对路径，即文件的存储地址\n    ```\n\n* **img标签**\n\n  ```\n  <img src=\"图片地址\" alt=\"图片加载失败或加载时的文字\" title=\"网页靠近图片时显示的名字\">\n  ```\n\n  + 图片的来源\n\n    + 本地图片：稳定\n\n    + 线上图片：图片容易丢失\n\n    + Base64图片\n\n      优点:小图片占用内存少，不请求服务器，降低服务器资源与访问\n\n      缺点：大图片增加了数据库服务器的压力\n\n  + 点击图片跳转\n\n    + 通过嵌套a标签 \n\n      `<a href=\"网站地址\"> <img>标签  </a>`\n\n* **表格table标签**\n\n  + 表的基本结构\n\n    由一行或者多行的单元格数据组成\n\n    | 姓名 | 性别 | 年龄 |\n    | ---- | ---- | ---- |\n    | 张三 | 男   | 18   |\n    | 李四 | 女   | 18   |\n\n  + 在HTML中表示\n\n    + table：HTML表格\n\n    + tr：元素定义表格行\n\n    + th：数据中的表格头单元格（相当于有多少列）\n\n    + td：表示单元格\n\n    ```\n    <table> border=\"1\" cellspacing=\"10px\" cellpandding=\"10px\"\n       <tr>\n          <th>姓名</th>\n          <th>性别</th>\n          <th>年龄</th>\n       </tr>\n       <tr>\n          <th>张三</th>\n          <th>男</th>\n          <th>18</th>\n       </tr>\n       <tr>\n          <th>李四</th>\n          <th>女</th>\n          <th>18</th>\n       </tr>\n    </table>\n    ```\n\n   + table元素李常用的属性\n\n     + border（边框）\n     + cellspacing（规定单元格之间的空白）\n     + cellpadding（规定单元格沿与其内容之间的空白）\n     + colspan（用于合并列）\n     + rowspan（用于合并行）\n\n* **列表ul、ol标签**\n\n  + 有序列表 \n\n    ```\n    <ol>\n      <li></li>\n    </ol>\n    ```\n\n   + 无序列表(使用的最多)\n\n     ```\n     <ul>\n       <li></li>\n     </ul>\n     ```\n\n    + 定义列表\n\n      ~~~\n      <dl>\n        <dt>人</dt>\n        <dd>一种哺乳动物</dd>\n      </dl>\n      ~~~\n\n* **表单form标签**\n\n  使用场景需要提交一些信息到服务端的时候（前后端联调过程中）\n\n  + 核心元素input（核心元素）`<input type=\"text\">`表示一个基本的文本框\n\n  + label（提高交互体验的）\n\n    ```\n    第一种\n    <label>\n       <input type=\"checkbox\">同意\n    </label>\n    第二种\n    <label for=\"\">同意</label>\n    <input type=\"checkbox\" id=\"isagree\">\n    ```\n\n  + select（下拉框）\n\n    ```\n    <select>\n       <option value=\"1\">男</option>\n       <option value=\"2\">女</option>\n    </select>\n    ```\n\n    \n\n  + textarea（文本域）\n\n  + button（按钮）\n\n    ```\n    <button type=\"submit\">注册</button> 点击网页的这个按钮就讲这个传给form 后面的action给后台\n    ```\n\n    \n\n  + form（表氮元素，提交每个表单项内容）\n\n* **区块和行内标签**\n\n  + div元素(用的很多)\n\n    + div元素是块级元素，他可以用于组合其他HTML元素的容器\n    + div元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行\n    + 如果与CSS一同使用，div元素可以用于对打的内容块设置样式属性\n    + div元素的另一个藏剑的用途是文档布局\n\n  + span元素（用的很多）\n\n    + span元素是行内元素，可以作为文本的容器\n    + span元素也没有特定的含义\n    + 当与CSS一同使用时，span元素可用于为部分文本设置样式属性\n\n  + 块级元素\n\n    + 块级元素在浏览器显示时，通常会以新行来开始（和结束）\n\n      `<h1><p><ul><table><div>`\n\n  + 行内元素\n\n    + 行内元素在显示时通常不会以新行开始\n\n      `<b><td><a><img><span>`\n\n## CSS\n\n##### CSS基础知识\n\n* **基础规则**\n  + 选择器：告诉浏览器要设置样式的html元素\n  + 声明块：用于设置样式\n  + 层叠样式表（相同的设计最后一个会覆盖前面的设计）\n  + Viewport：将网页的视口设置为完美视口，开发移动端页面时一定要加上\n* **CSS的几种推荐写法**\n  + 写法\n    + 內部样式表：写在元素的style标签里面的\n    + 内联样式表：写在div 里的styles属性里面的\n    + 外部样式表：link标签将css资源引入\n  + 为什么采用外部样式表\n    + 解决页面当中样式重复的问题\n    + 代码分离，利于代码维护和阅读\n    + 浏览器会缓存起来，提高页面相应速度变快了\n\n##### CSS核心技术\n\n* 选择器的选择\n\n  + 元素（标签）选择器\n\n    `组合选择器：h1,p{color:red;}`当属性相同时可以节省很多代码行\n\n  + 类选择器\n\n    + 结合标签选择器\n\n      ```h1.xiaodi{color:red;}\n      在div里声明class <div class=\"yzp\">余贞佩</div>\n      则可以在style下用.yzp{}编辑属性\n      <p class=\"yzp\">余贞佩</p>\n      可以用p.yzp{}进行编辑\n      ```\n\n    + 多类选择器\n\n      ```class=\"yzp background\"\n      <div class=\"yzp background\">余贞佩</div>\n      可在style下.class{}和.background{}进行编辑如果使用.background.yzp{}的话在编辑内容里面必须包含两个\n      ```\n\n  + id选择器\n\n    ```\n    声明：#important{}\n    属性：id=\"important\"\n    \n    注意：一个id选择器的属性值在html文档中只能出现一次，避免写js获取id时出现混淆\n    ```\n\n   + 通配符选择器\n\n     将所有的都修改但优先级很低\n\n   + 派生选择器\n\n     + 后代选择器\n\n       ```\n       h1 p{color:red;}\n       <h1>\n          <p>余贞佩</h>\n       </h1>只要是h1下p中相同的标签都可以修改\n       ```\n\n     + 子元素选择器\n\n       ```\n       h1>p{}表示修改h1中的p标签而不修改h2\n       <h1>\n          <p>余贞佩</p>\n       </h1>\n       <h2>\n          <p>余贞佩</p>\n       </h2>\n       ```\n\n      + 相邻选择器(兄弟选择器)\n\n        `h1+p{background-color:pink;}`\n\n        必须要有相同的父级才能修改，但是是从第二个开始\n\n* 特殊的选择器\n\n  1. 伪类选择器\n\n  + 不改变任何DOM内容。只是插入了一些修饰类的元素\n    ![](C:\\Users\\阿余\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220803180725240.png)\n\n2. 伪元素选择器\n\n```\n::first-letter  //第一个元素\n::first-line  //第一行 只能用于块级元素\n::selection  //选中\n::before   //在开始位置\n::after  //在结束位置\n```\n\n##### CSS基础概念之盒子模型\n\n1. 盒子的内边距（padding）\n\n   ![](C:\\Users\\阿余\\AppData\\Roaming\\Typora\\typora-user-images\\盒子的内边距.png)\n\n2. 盒子的边框（border）（宽度，样式，颜色）\n\n   ![](C:\\Users\\阿余\\AppData\\Roaming\\Typora\\typora-user-images\\盒子的边框.png)\n\n3. 盒子的外边距（margin）\n\n   ![](C:\\Users\\阿余\\AppData\\Roaming\\Typora\\typora-user-images\\盒子的外边距.png)\n\n   * 盒子怪异模型 \n\n     + W3C标准盒子模型（标准盒模型）变大\n\n       `boxWitdth=contentWidth`\n\n     + IE标准盒子模型（怪异盒模型）图片不改变时使用，外边框不改变\n\n       `box-sizing:，border-box`//声明\n\n       `boxWidth=contentWidth+border+padding`\n\n   * 外边距折叠\n\n     + 上下两个兄弟盒子的margin都为正则取大，都为负则取小，一正一负两者相加\n\n     + 父子元素盒子的margin（假设没有内边距或边框那外边距分隔开），也会合并；只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对之间的外边距不会合并\n\n       ```\n       解决父子边距合并：\n       父元素{\n        overflow:auto;\n       }\n       父元素::before{\n          display:table;\n          content:\"\";\n       }\n       ```\n\n* **CSS的常用属性 **\n\n  + 盒子的位置和大小\n\n    ```\n    宽度 width: 长度|百分比|auto\n    高度 height\n    边界 margin padding 上右下左|上下左右\n    ```\n\n   + 布局\n\n     ```\n     浮动： float\n     定位：position\n     弹性布局：flex\n     盒子内容超出部分：overflow:hidden|scroll|auto   隐藏|滑动|滑动\n     ```\n\n    + 外观、风格\n\n      ```\n      background-image: url('图片地址');\n      background-repeat: no-repeat\n      background-size:100%|50%\n      background-position:center|bottom\n      background-color: red;\n      background: red url('') no-repeat center;\n      background-size:100%;\n      ```\n\n     + 文字属性\n\n       ```\n       font-size  字体大小\n       font-weight  是否加粗\n       font-style  是不是斜体\n       font-family  字体是什么\n       ```\n\n* **CSS的层叠与选择器优先级**\n\n  + CSS全称：层叠样式表表（Cascading Style Sheets）\n\n  + 层叠是一个基本特征\n\n    一个css属性被多次声明的时候，会根据优先级或者声明顺序来计算采用哪个样式\n\n  + 优先级怎么计算\n\n    + 通配符选择器1：*\n\n    + 标签选择器2：div  span  p  li\n\n    + 类选择器3： class\n\n    + ID选择器4： ID\n\n    + 行内样式5  <div style=\"color:pink\">内容</div>>是直接在标签里\n\n    + ！impoant6（尽量不要再公用代码里使用）\n\n      注意：1是最低级往下升高\n\n+ **CSS常见的继承属性**\n\n  + 什么是继承\n\n    + 继承了父元素的某些特征\n    + 优点：继承可以简化代码，便于维护\n\n  + 默认设置继承的属性\n    文字属性，文本缩进，对齐，行高\n\n    ```\n    文本缩进 text-indent:50px(为正表示向右，为负向左移)\n    对齐  text-align: right(向右对齐)\n    行高 line-height:50px;\n    ```\n\n+ **CSS布局定位**\n\n  + 前置知识\n\n    + 正常元素的布局\n      1. 默认，一个块级元素的内容宽度就是其父元素的100%，它的高度与其内容高度一致\n      2. 行内元素他的高度和宽度都是根据内容决定的（无法设置行内元素的宽高）\n         + 可设置display属性将行内元素设置为块级元素，定义元素类型（Css3定义布局）\n    + 元素之间如何相互影响\n      + 正常的文档布局流\n        + 每个块级元素会在上一个元素下面另起一行\n        + 行内元素不会另起一行\n\n  + **CSS中float布局**（实现左右布局）\n\n    + float布局\n\n      ```\n      float:none;  //默认值，元素不浮动\n      float:left;  //元素向左浮动\n      float:rght;   //元素向有浮动\n      ```\n\n    + 特点\n\n      + 浮动元素会脱离文档流，不再占用文档流空间\n      + 浮动元素彼此之间是从左往右排列，宽度超过一行自动换行\n      + 在浮动元素前面元素不浮动时，浮动无法上移\n      + 块级元素和行内元素浮动之后都变成行内块级元素\n      + 浮动元素不会盖住文字，可以设置文字环绕效果\n\n    + 清除浮动\n\n      ```\n      在伪元素里设置\n      .box::after{\n      clear:both;\n      content='';\n      display:block;\n      }\n      ```\n\n  + **CSS中flex布局**（弹性布局）\n\n    + 父元素容器的属性\n\n    ```\n    1.父级设置为flex布局以后，子元素的float、clear和vertical-algin属性将失效\n    display：flex；\n    2.决定主轴的方向（即项目的排列方向）\n    flex-direction：row|row-reverse|column|column-reverse（水平方向|相反|垂直方向|相反）\n    3.是否换行\n    flex-wrap：nowrap|wrap|wrap——reverse（不换行|换行|颠倒换行）\n    4.定义水平方向对齐（用的很多）\n    justify-content：flex-end|center|space-between|space—around（从主轴右边开始|居中放在中间|两边占完，且中间居中|左右有距离边框，其余子元素的间距是两边元素距离边框距离的两倍）\n    5.定义垂直方向对齐\n    align—items：flex-end|center|baseline|stretch；（从反方向开始|居中|需要在子元素中添加line—height|需要把子元素中的height去掉，即去掉高度占满竖直方向）\n    6.定义多个轴线（多行、多列）对齐方式\n    align-content:flex-start|flex-end|center|space-between|space-around|stretch;(从上开始|从下往上|居中|)\n    ```\n\n    + 子元素容器属性\n\n      ```\n      1.定义子元素的排列顺序，默认为0\n      order：-10|-1|0|1|10;(越小越靠前，越大越靠后，没设置则默认为零)\n      2.定义子元素的放大比例，默认为0\n      flex-grow:0|1|2|3;(当设置为0时，若容器没满则不占据剩余的容器空间，若设置为1，则会把空间占满)\n      3.定义子元素的缩小比例，默认为1（则会被缩小）\n      flex-shrink:0|1;\n      4.定义在分配多余空间之前，项目占据的主轴空间（设置宽度）\n      flex-basis:<length>|auto;\n      5.flex-grow,flex-shrink和flex-basis的简写(推荐)\n      flex:0   1  auto;\n      兼容性\n      需要浏览器ie9以上\n      ```\n\n  + 怎么选择float和flex\n\n    + 推荐使用flex布局\n      1. flex布局易用，布局全面\n      2. float的创建初衷只是为了达到文字环绕的效果，另外需要清除浮动\n      3. 现在几乎所有的公式参评使用场景都在浏览器IE9以上\n\n+ **CSS中的position定位**\n\n  + 是为了布局引入的属性\n\n  + position常用的几个值\n\n    ```\n    position: static （静态定位） 父元素（默认值）\n    position: relative （相对定位） 父元素\n    position: absolute （绝对定位） 父元素（会寻找父级的relative）\n    \n    \n    position: fixed（固定定位） 父元素（固定在页面位置不动）\n    position: sticky （粘性定位） 父元素（当下滑快到下面时会在顶部不会消失）\n    \n    ```\n\n   + 相关属性\n\n     `z-index  //使用场景：当定位的盒子重叠在一起（即谁优先展示）`\n\n+ **CSS三栏布局如何实现**\n\n  + 问题：高度固定，左右两侧的盒子宽度为200px，中间自适应\n  + 解决方法\n    + float（中间的放在最下面）\n    + position（absolute，左右为零，中间放在下面）\n    + flex（中间的flex ： 1;）（最方便）\n\n+ **CSS实现水平垂直居中**\n\n  + 行内块元素（在span中display:inline-block）\n\n    ```\n    1.line-height:为行内块的height\n      text-align: center\n    2.display:flex;常用\n    justify-content:center\n    align-items:center\n    ```\n\n   + 块级元素\n\n     ```\n     1.position+margin(自身的子元素的-一半)清楚子元素的宽高\n     2.position+transform（transform:translate(--50%,-50%)）不清楚子元素的宽高\n     3.flex\n     4.table-cell兼容性差\n     ```\n\n+ **CSS高级知识点BFC**\n\n  + 定义\n    + 块格式化上下文：是web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域\n    + 即：形成了一块封闭的区域，能检测到区域内脱离文档流的元素\n  + 特点\n    + CSS中隐含的属性，开启后不会被浮动的元素覆盖\n    + BFC元素可以包含浮动元素\n    + BFC元素的子元素和父元素外边距不重叠\n  + 开启（都会有副作用）\n    + 设置元素浮动float：left\n    + 设置为行内块元元素display：inline-block\n    + overflow：hidden（推荐）\n  + 作用\n    + 清除浮动带来的影响\n    + 解决边距塌陷问题（外边距折叠也只会发生在属于同一BFC的块级元素之间）\n\n+ **CSS边框**\n\n  + 圆角\n\n    `border-radius:10px 10px 10px 10px左上 右上 右下 左下（即顺时针）`\n\n  + 盒阴影\n\n    `box-shadow：10px 10px 10px 颜色（左右平移|上下平移|阴影程度|阴影颜色）`\n\n  + 边界图片\n\n    `border-image`\n\n+ **CSS渐变**\n\n  + 基本语法\n\n    ```\n    1.background-image: linear-gradient(颜色，颜色)从上到下渐变（默认）\n    2.background-image: linear-gradient(to right,颜色，颜色)从左到右渐变\n    3.background-image: linear-gradient(to bottom right，颜色，颜色)对角线渐变\n    ```\n\n  + 角度变化也是，180是从上往下，90是左往右，0是下往上\n\n  + 多个颜色同样按上面的\n\n  + 透明度（用的最多）\n\n    `background-image: linear-gradient(rgba(255,0,0,0),rgba(255,0,0,1))`rgba()里面的前三个值时颜色的值，最后一个的值1是不透明，0是透明，最后一个值表示透明度\n\n  + 重复\n\n    `background-image: repeating-linear-gradient(red,yellow 10%,green 20%)`1除以10%表示重复十个，1除以20%表示重复五个\n\n+ **CSS文本效果**\n\n  + 文本阴影\n\n    `text-shadow:5px 5px 5px 颜色(水平方向|垂直方向|阴影程度|阴影颜色)`\n\n  + 文本溢出\n\n    ```\n    1.超出一行省略\n    \n    overflow：hidden\n    \n    white—space：nowrap\n    \n    text-overflow：cellispsis |clip(表示省略号|裁剪)\n    \n    2.超出两行省略\n    overflow:hidden\n    text-overflow:cellispsis\n    -webkit-box-orient:vertical;\n    -webkit-line-clamp:2;\n    ```\n\n  + 文本换行\n\n    + 长文本换行\n\n      `word-wrap:break-word`\n\n    + 单词拆分换行\n\n      `word-break:break-all`\n\n+ **CSS3网格布局**\n\n  + flex布局，float布局应用于一维布局，网格布局应用于二维布局\n\n  + 父元素属性\n\n    ```\n    1.使用\n    display: grid\n    grid-template-columns:10px 10px 10px;\n    grid-template-rows:10px 10px 10px;表示三行三列\n    2.百分比使用\n    display: grid\n    grid-template-columns:33% 33% 33%;\n    grid-template-row:33% 33% 33%;表示三行三列\n    3.repeat()函数简化\n    display: grid\n    grid-template-columns:repeat(3,33.33%)\n    grid-template-row:repeat(3,33.33%);表示三行三列\n    ```\n\n* **项目实战**\n\n  + <link rel=\"shortcut icon\" href=\"图片地址\" type=\"image/x-icon\">图标\n\n  + link:css 可以导入CSS模板\n\n  + 阿里巴巴矢量库:\n\n  + 引入第三方icon\n\n    ```\n    //根文件html导入\n    `<script src=\"http:复制的地址\"></script>`\n    //使用\n    <svg class=\"icon\" aria-hidden=\"true\">\n        <use xlink:href=\"#xxx\"></use>\n    </svg>\n    ```\n\n    \n\n    ","tags":["HTML和CSS"],"categories":["前端"]}]