[{"title":"多线程并发编程","url":"/2022/12/07/多线程并发编程/","content":"#### 什么是并发编程\n\n+ 串行和并行的区别：并行可以缩短整个流程的时间\n+ 并发编程的目的:从某种程度上加快程序响应的速度（耗时任务，web服务器），简化异步事件的处理，让程序充分利用计算机资源\n+ 什么时候适合使用并发编程：\n  + 任务会阻塞线程，导致之后的代码不能执行：比如一边从文件中读取，一边进行大量的计算的情况\n  + 任务执行时间过长，可以划分为分工明确的子任务：比如分段下载\n  + 任务间断性执行：日志打印\n  + 任务本身需要协作执行：比如生产者消费者问题\n\n#### 并发编程挑战频繁的上下文切换\n\n+ 上下文的频繁切换，会带来一定的性能开销\n+ 如何减少上下文切换的开销？\n  + 无锁并发编程\n    + 无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的id按照hash算法取模分段，不同的线程处理不同分段的数据\n  + CAS\n    + Java的Atomic包使用的CAS算法来更新数据，而不需要加锁\n  + 使用最少的线程\n    + 避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态\n  + 协程（go语言使用的多，就Java很少使用）\n\n#### 并发编程挑战死锁\n\n+  在cmd控制台输入jconsole可以查看是否出现死锁\n\n#### 并发编程挑战线程安全\n\n+ ~~~java\n  public class UnSafeThread{\n      private static int num=0;\n      private static CountDownLatch cdl=new CountDownLatch(10);\n      \n      \n      public static void inCreate(){\n         num++;\n      }\n      public static void main(String []args){\n      for(int i=0;i<10;i++){\n          new Thread(()->{\n            for(int j=0;j<100;j++){\n            inCreate();\n            Thread.sleep(10)://会抛异常需要捕获\n            }\n            //每个线程执行完成之后，调用countdownlatch\n            cdl.counyDown();\n  }).start();\n      }\n      while(true){\n        if(cdl.getCount()==0){\n           System.out.println(num);\n           break;\n        }\n      }\n      }\n  \n  }\n  ~~~\n\n\n\n#### 并发编程挑战资源限制\n\n+ 硬件资源\n  + 带宽的上传和下载熟读，硬盘的读写速度和CPU的处理速度\n+ 软件资源\n  + 数据库连接 500个连接，1000个线程查询，并不会因此加快，socket（最大打开数）\n\n#### 线程的基础知识\n\n+ 进程和线程的区别\n\n  + 进程：是系统进行分配和管理资源的基本单位\n  + 线程：进程的一个执行单元，是进程内调度的实体，是CPU调度和分配和分派的基本单位，是比进程更小的独立运行的基本单位。线程也被称为轻量级进程，线程是程序执行的最小单位\n  + 一个程序至少一个进程，一个进程至少一个线程\n  + 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段，堆栈段和数据段，这种操作十分昂贵\n  + 而线程是共享进程中的数据的 ，使用相同的地址空间，因此cpu切换一个进程的花费远比进程要小很多 ，同时创建一个线程的开销也比进程要小很多\n  + 线程之间的通信更方便，同一个进程下的先后才能共享全局变量，静态变量等数据，而进程之间的通信需要以通信的方式进行\n  + 如何处理好同步与互斥是编写多线程程序的难点\n  + 多进程程序更健壮，进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其他的进程产生影响，而线程只是进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间，没有独立的地址空间，所以可能一个线程出现问题，进而导致整个程序出现问题\n\n+ 线程的状态及其相互转换\n\n  + 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法\n\n  + 运行(runnable)：chuy7u可运行状态的线程在JVM中执行，但他可能正在等待来自操作系统的其他资源，例如处理器\n\n  + 阻塞(blocked)：线程阻塞与synchronized锁，等待获取synchronized锁的状态\n\n  + 等待(waiting)：Obiect.wait(),join(),LockSupport.park(),进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）\n\n  + 超时等待(time_waiting):\n\n    Object.wait(long),Thread.join(),LockSupport.parkNanos(),LockSupport.parkUntil，该状态不同于waiting，他可以在指定的时间内自行返回\n\n  + 终止(terminated)：表示该线程已经执行完毕\n\n  + 他们之间的相互转换\n\n    ![](https://picgo-1309496466.cos.ap-chongqing.myqcloud.com/pic/image-20220913094152576.png)\n\n+ 创建线程上\n\n  + 第一种是直接继承Thread，并重写父类的run方法\n\n    ```java\n    public class MyThread extends Thread{\n       @Override//重写run方法\n       public void run(){\n          System.out.println(Thread.currentThread.getName());\n       }\n       \n       public static void main(String []args){\n         MyThread myThread=new MyThread();\n         mythread.setName(\"余贞佩真帅\");\n         myThread.start();\n         }\n    }\n    ```\n\n  + ()第二种直接实现Runable接口，并实现run方法\n\n    ```\n    public class MyRunable implements Runable{\n       @Override//重写run方法\n       public void run(){\n         System.out.println(Thread.currentThread().getName());\n       }\n       \n       public static void main(String []args){\n          Thread thread=new Thread(new MyRunable());\n          thread.setName(\"余贞佩是帅哥\");\n          thread.start();\n          \n          \n          //不使用thread.start而直接使用run的话,不会启动线程，只会启动原本的线程，在实际开发中需要用thread.start()\n          thread.run();\n       }\n       \n    }\n    ```\n\n  + 实际开发中，选第二种，因为Java只支持单继承，支持多接口，还可以增加程序的健壮性，代码可以共享，代码和数据相对独立\n\n+ 创建线程下\n\n  + 使用匿名内部类的方式（也是runnable）\n\n    ```\n    public class MyThread{\n       public static void main(String []args){\n       Thread thread=new Thread(new Runnable(){\n         @Override\n          public void run(){\n          System.out.println(\"余贞佩真帅\");\n       }\n       );\n          \n    }\n       }\n    }\n    ```\n\n   + 使用Lambda\n\n     ```\n     public class Lambda{\n         public static void main(String []args){\n         new Thread(()->{\n            System.out.println(\"余贞佩真帅\");\n         }).start();\n         }\n     }\n     ```\n\n    + 使用线程池的方法ExecutorService\n\n      ```\n      public class ThreadPool{\n         public static void main(String []args){\n         ExecutorService executorSevice=Executor.newSingleThreadExecutor();\n         executorService.execute(()->{\n         System.out.println(\"余贞佩真帅\");\n       \n         });\n           }\n      }\n      ```\n\n+ 线程的挂起和恢复\n\n  + 什么是挂起线程\n\n    + 线程的挂起操作实质上就是使线程进入“非可执行”状态，在这个状态下cpu不会分给线程时间片，进入这个状态可以用来暂停一个线程的运行，在线程挂起后，可以通过重新唤醒线程来恢复运行\n\n  + 为什么要挂起线程\n\n    + cpu分配的时间片非常短，同时也非常珍贵，避免资源的浪费\n\n  + 如何挂起线程\n\n    + thread.suspend();//挂起   不会释放线程所占用的资源，如果使用该方法将某个线程挂起，则可能使其他等待资源的线程死锁\n\n    + thread.resume();//唤醒       脱离了suspend就无法使用，无法单独使用。这两个方法不用了\n\n    + 可以使用的方法\n\n      + wait();//暂停执行，放弃已获得的锁，进入等待状态\n\n      + notify();//随机唤醒一个在等待锁的进程\n\n      + notifyAll();//唤醒所有在等待锁的进程，自行抢占cpu资源\n\n      + ```\n        public class WaitDemo{\n             private  static Object waObject=new Object();\n             @Override\n             public void run(){\n             //特有资源\n             synchronized(waObject){\n              System.out.println(\"yuzhenpe\"+\"余贞佩\");\n              waObject.wait();//这里需要捕获异常\n             }\n             System.out.println(\"太帅了\");\n        }\n           public static void main(String []args){\n           Thread thread=new Thread(new WaitDemo(),name\"线程名字\");\n           thread.start();\n           Thread.sleep(1000L)//休眠一秒钟\n           synchronized(waObject){\n           waObject.notify();\n        }\n           }\n        }\n        \n        注意：在使用的时候需要注意两个都需要持有锁，并且都需要是锁住的是相同的对象\n        ```\n\n  + 什么时候适合使用挂起线程\n\n    我等的船还不来（等待某些未就绪的资源，让出时间片给其他的线程，直到notify唤醒）\n\n+ 线程的中断操作\n\n  + stop();//已经废弃的方法，不要使用。因为一调用，线程就立刻停止，此时有可能引发相应的线性安全性问题\n\n  + interrupt();方法\n\n    ```\n    public class InterruptDemo implements  Runnable{\n        @Override\n        public void run(){\n          while(!Thread.currentThread().isInterrupt()){//判断是否被interrupt方法标记了中断线程\n              System.out.println(\"余贞佩真帅\");\n          }\n        }\n        \n        public static void main(String []args){\n           Thread thread=new Thread(new InterruptDemo());\n           thread.start();\n           Thread.sleep(3000L);\n           thread.interrupt();//调用这个方法会给线程标记中断线程的标记\n        }\n    \n    }\n    ```\n\n  + 通过volatile来定义变量来实现\n\n    ```\n    public class MyInterruptDemo imlements Runnable{\n        private static volatile boolean flag=ture;//这里一定需要加volatile关键字\n        @Override\n        public void run(){\n        while(flag){\n          System.out.println(\"余贞佩真帅\");\n        }\n        }\n        public static void main(String []args){\n          Thread thread=new Thread(new MyInterruptDemo());\n          thread.start();\n          Thread.sleep(1000L);\n          flag=false;//通过修改volatile修饰的变量来控制退出循环中断线程\n        }\n        \n    }\n    ```\n\n+ 线程的优先级\n\n  + 线程的优先级会告诉程序该线程的重要程度。如果大量线程都被堵塞，都在等候运行，那么程序会尽可能的优先运行优先级高的线程。不代表优先级低的线程不会被运行，只是被运行的机会比较少\n\n  + 设置线程的优先级\n\n    ```\n    public class PriorityDemo{\n         \n         public static void main(String []args){\n           \n           Thread thread1=new Thread(()->{\n               System.out.println(Thread.currentThread().getName()+\"余贞佩真帅\");\n           },\"线程1\");\n           Thread thread2=new Thread(()->{\n               System.out.println(Thread.currentThread().getName()+\"余贞佩真帅\");\n           },\"线程2\");\n           thread1.setPriority(MIN);//设置为1到10之间的整数，Priority提供了1,5,10三种（建议）\n           thread2.setPrioity(MAX);\n           thread1.start();\n           thread2.start();\n         }\n    }\n    ```\n\n  + 线程优先级可以设置为1-10的任意数值，Thread类定义了三个数值表示线程优先级，MIN_PRIORity(1);NORM_PRIORITY(5);MAX_PRIORITY(10);一般情况推荐使用这三种，不要自行设置数值\n\n  + 不同的平台对线程优先级的支持不同\n\n    + 编程的时候不要过度依赖线程优先级，如果程序的运行是否正确取决于你设置的优先级是否按所设置的优先级运行，那这样的程序不正确\n\n  + 任务是快速处理就设置为优先级高\n\n  + 任务是慢慢处理就设置为优先级低（但是得保证不影响程序运行）\n\n+ 守护线程\n\n  + 线程分类：用户线程，守护线程\n\n  + 守护线程\n\n    + 任何一个守护线程都是用户线程的守护者，只要有用户线程活着，守护线程就活着。在JVM实例中最后一个非守护线程结束时，也随JVM一起退出\n    + 作用：JVM垃圾清理线程\n\n  + 在开发中少使用守护线程，因为其不可控，容易在运行到一半的时候随着用户线程的消失而消失，如果一定要使用守护线程，也不要在守护线程进行读写计算等逻辑\n\n  + 在Java中设置守护线程\n\n    ```\n    public static void main(String []args){\n          Thread thread=new Thread(new Yzp());\n          thread.setDaemo(ture);//系统默认false\n          thread.start();\n          //注意，设置为守护线程一定需要在thread.start()之前，在之后不会被设置为守护线程\n    }\n    ```\n\n\n#### 线程安全\n\n+ 线程安全性问题\n\n  + 什么是线程安全性\n    + 当多个线程访问某个类，不管运行环境如何调度或线程如何交替执行，并且在主调代码中不需要任何额外的同步或者协同，这个 类都能做出正确的行为，那么这个类是线程安全的\n  + 什么是线程不安全\n    + 多线程并发访问的时候，得不到正确的结果\n\n+ 从字节码剖析线程不安全操作\n\n  + 例子：num++不是原子性操作，被拆分为多个步骤，在多线程并发执行的时候，因为cpu的调度，多线程快速切换，有可能多个线程在同一个时刻读取了同一个num的值，然后对相同的num值进行++，得不到正确的结果，导致线程安全性问题\n\n+ 原子性操作\n\n  + 什么是原子性操作\n\n    一个操作或多个操作在执行的过程中不会被任何因素阻断，要么都不执行\n\n  + 如何把非原子性操作变为原子性操作\n\n    + volatile关键字仅仅保证可见性，并不能保证原子性\n\n    + synchronized关键字，可以使操作具有原子性\n\n + synchronized关键字\n\n   + 内置锁\n\n     每一个Java对象，都可以用做一个实现同步的锁，这些锁称为内置锁。线程进入同步代码块或者方法的时候会自动获得该锁，在退出同步代码块或者方法的时候会释放该锁\n\n     获得内置锁的唯一途径是进入这个锁所保护的同步代码块或方法\n\n   + 互斥锁\n\n     + 内置锁是一个互斥锁，这就意味着最多只有一个线程可以获得这个锁，当线程a尝试获得线程b所持有的锁的时候，线程a会进入堵塞或者等待状态，直到线程b释放这个锁\n     + 如果线程b一直不释放锁，那么线程a就会一直等待或者堵塞\n\n   + 修饰普通方法：锁住的是类的实例`public synchronized void test()`\n\n   + 修饰静态方法：锁住的是整个类（最好不要用）`public static synchronized`staticTest()\n\n   + 修饰代码块：锁住的是一个对象。锁住的是synchronized括号后面的那个对象\n\n     + ```\n       public void yzp(){\n          synchronized(对象){\n          \n          }\n       }\n       ```\n\n + volatile关键字\n\n   + 能且仅能修饰变量\n   + 保证变量的可见性，但是不能保证原子性\n   + 禁止指令重排序\n   + 比如：A,B两个线程同时读取被volatile修饰的对象，A线程的读取过后修改了变量的值，修改的值对于B线程来说是可见的\n   + 使用场景\n     + 作为线程的开关\n     + 单例，修饰对象的实例，禁止指令重排序\n\n + 单例与线程安全\n\n   + 饿汉式（本身线程安全）不需要加锁\n\n     在类加载的时候就已经实例化，不管用不用的到。如果该类占内存大，且后面也用不到，就白白浪费了资源\n\n     + 在idea有一个Singleton可以帮我们创建\n\n   + 懒汉式（最简单的写法是非线程安全的）\n\n     在需要的时候在进行实例化\n\n     ```\n     public class LazySingleton{\n           praivate static volatile LazySingle=null;//在这里需要volatile关键字来禁止指令重排序\n           private LazySingle(){//私有化\n     }\n          public static LazySingleton getInstance(){\n          //判断实例化是否为空，为空则实例化对象，否者直接返回\n          if(null==lazySingle){\n            Thread.sleep();//这里需要抛出异常\n            synchronized(LazySingle.class){\n              if(null==lazySingle){\n               lazysinglr=new LazySingle();\n     }\n            }\n          }\n          return lazySingle;\n          \n          }\n     }\n     这样是线程安全的\n     ```\n\n + 如何避免线程安全性问题\n\n   + 产生线程安全性的原因\n\n     + 多线程环境\n     + 多个线程操作同一个共享资源\n     + 对该共享资进行了非原子性操作\n\n   + 如何避免\n\n     打破三个成因其中一个\n\n     + 将多线程变为单线程（必要的代码，加锁访问）\n     + 不共享资源（ThreadLocal,不共享，或者将操作变为无状态，将变量变为不可变变量（final））\n     + 将非原子性操作变为原子性操作（加锁，使用jdk自带的原子性操作的类，juc提供的相应的并发工具类）\n\n#### 锁\n\n+ 锁的分类\n\n  <img src=\"https://picgo-1309496466.cos.ap-chongqing.myqcloud.com/pic/image-20220915162626728.png\" style=\"zoom: 50%;\" />\n\n  <img src=\"https://picgo-1309496466.cos.ap-chongqing.myqcloud.com/pic/image-20220915162807317.png\" style=\"zoom:50%;\" />\n\n+ 深入理解Lock接口\n\n  + Lock的使用\n\n    ```\n    private static Lock lock=new ReeentrantLock();\n    public static void inCreate(){\n       lock.lock();//在需要加锁的方法内加锁\n       num++;\n       lock.unlock();//需要手动的解锁\n    }\n    ```\n\n  + lock和synchronized的区别\n\n    + lock需要手动的加锁和解锁，synchronized则是托管给jvm去实现\n    + synchronized的机制是悲观锁，每个线程都是独占锁，独占锁意味着其他的锁只能依靠堵塞来等待释放锁\n    + lock是乐观锁，实现CAS操作\n    + 而synchronized现在与lock的性能差不多\n\n+ 实现自己的锁（具有重入的功能）\n\n  + ```\n    public class MyLock implements Lock{\n        \n        private boolean isHoldLock=false;\n        private Thread holdLockThread=null;\n        private int reentryCount=0;\n    \n        //重写Lock类的方法\n        //在同一时刻有且只有一个线程能获的锁，其他的线程需要等待这个线程释放锁后才能获得锁\n        @Override\n        public synchronized void lock(){//需要用到wait和notify方法所以需要在方法上面上锁\n            if(isHoldLock&&holdLockThread!=Thread.currentThread()){\n                  wait();//这里需要抛出异常\n            }\n            holdLockThread=Thread.currentThread();\n            isHoldLock=true;  \n        }\n        @Override\n        public synchronized void unlock(){\n        //判断当前线程是否持有锁，如果是，重入数就减一，不是就不做处理\n           if(Thread.currentThread==holdLockThread){\n               reentryCount--;\n              if(reentryCount==0){\n               notify();\n               isHoldLock=false;\n              }\n          }\n        }\n    \n    }\n    ```\n\n+ AbstractQueuedSynchronizer浅析\n\n+ ReentrantLock源码（new的时候带参数TRUE就是公平锁，不带参就是非公平锁）\n\n+ ReentrantLock公平锁和非公平锁的区别\n\n  + 公平锁遵守排队规则，比如在公共厕所上厕锁，只要前面的在排队，那么刚进来的就会老老实实的排队\n  + 非公平锁有点像流氓，只要当前有空的坑位，他就会直接霸占，不管后面排队的人。只要有机会就会抢占资源\n\n+ 非公平锁的弊端\n\n  + 可能导致后面等待的线程等不到相应的cpu资源从而引起线程饥饿\n\n+ 掌控线程的执行顺序之多线程Debug\n\n  + 在使用ReentrantLock类的时候释放锁的操作需要放在异常finally里面\n  + \n\n","tags":["并发编程"]},{"title":"HTML和CSS基础","url":"/2022/12/06/HTML和CSS基础/","content":"## HTML\n\n##### 基础知识\n\n* 常见的几个标签：\n\n  ```\n  <meta>标签是放在<head>下的,没有结束标签为自结束标签\n  <a herf>标签是放在<body>下的，定义一个超链接，用于跳转网站\n  &nbsp;  这个是在网页中加空格，要添加多少空格就写多少次\n  <link>标签是放在<title>下的，用于链接外部的样式表\n  <hr>标签是放在<body>下的，加一条横线区分上半段和下半段\n  <img>标签是放在<body>下的，在网页中添加图片，其中src后面是放图片的地址，alt后面是图片的标签\n  <input>标签是放在<body>标签下的，创建一个输入框\n  ```\n\n* 注释\n\n  + 当代码复杂度大时，便于解释说明代码的含义\n  + 注释暂时用不到的代码片段\n  + 注释不能嵌套，否则网页中会渲染出-->\n\n* 语义化标签\n\n  ```\n  <title>网页标签是网站和标签的名字\n  <h1>~<h6>：网页内容的标题(最好只使用一个h1)一般使用h1~h6\n  <p>标签是换行的操作，相当于Word里面的回车换行\n  <strong>强调加粗度字体\n  下面几种很少用到：\n  头部元素：header\n  导航元素：nav\n  主要内容：main\n  ```\n\n  + 优化代码结构：在页面没有css的情况下，也能够呈现出很好的内容结构\n  + 有利于SEO：标签确定关键字的权重，因此可以增加搜索相关权重，使网站搜索结果中的排列顺序\n\n##### 具体知识\n\n* **a标签的用法**\n\n  ```\n  跳转：<a href=\"网站地址\">网站名字</a>\n  锚点：<a href=\"#xxx\">网页中的点击名字</a>（用于点击网页跳转）\n  点击网页跳转并打开另一个浏览器界面：<a href=\"网站地址\" target=\"blank\">网页中的点击名</a>\n  ```\n\n* target属性\n\n  + blank：打开新的浏览器标签\n\n* 路径\n\n  根据资源的类型判断，一般站外资源用绝对路径，站内资源用相对路径\n\n  + 绝对路径\n\n    `https://xdclass.net`\n\n  + 相对路径\n\n    ```\n    ./ 代表当前目录\n    ../ 代表的上一级目录\n    内部的资源也可以用绝对路径，即文件的存储地址\n    ```\n\n* **img标签**\n\n  ```\n  <img src=\"图片地址\" alt=\"图片加载失败或加载时的文字\" title=\"网页靠近图片时显示的名字\">\n  ```\n\n  + 图片的来源\n\n    + 本地图片：稳定\n\n    + 线上图片：图片容易丢失\n\n    + Base64图片\n\n      优点:小图片占用内存少，不请求服务器，降低服务器资源与访问\n\n      缺点：大图片增加了数据库服务器的压力\n\n  + 点击图片跳转\n\n    + 通过嵌套a标签 \n\n      `<a href=\"网站地址\"> <img>标签  </a>`\n\n* **表格table标签**\n\n  + 表的基本结构\n\n    由一行或者多行的单元格数据组成\n\n    | 姓名 | 性别 | 年龄 |\n    | ---- | ---- | ---- |\n    | 张三 | 男   | 18   |\n    | 李四 | 女   | 18   |\n\n  + 在HTML中表示\n\n    + table：HTML表格\n\n    + tr：元素定义表格行\n\n    + th：数据中的表格头单元格（相当于有多少列）\n\n    + td：表示单元格\n\n    ```\n    <table> border=\"1\" cellspacing=\"10px\" cellpandding=\"10px\"\n       <tr>\n          <th>姓名</th>\n          <th>性别</th>\n          <th>年龄</th>\n       </tr>\n       <tr>\n          <th>张三</th>\n          <th>男</th>\n          <th>18</th>\n       </tr>\n       <tr>\n          <th>李四</th>\n          <th>女</th>\n          <th>18</th>\n       </tr>\n    </table>\n    ```\n\n   + table元素李常用的属性\n\n     + border（边框）\n     + cellspacing（规定单元格之间的空白）\n     + cellpadding（规定单元格沿与其内容之间的空白）\n     + colspan（用于合并列）\n     + rowspan（用于合并行）\n\n* **列表ul、ol标签**\n\n  + 有序列表 \n\n    ```\n    <ol>\n      <li></li>\n    </ol>\n    ```\n\n   + 无序列表(使用的最多)\n\n     ```\n     <ul>\n       <li></li>\n     </ul>\n     ```\n\n    + 定义列表\n\n      ~~~\n      <dl>\n        <dt>人</dt>\n        <dd>一种哺乳动物</dd>\n      </dl>\n      ~~~\n\n* **表单form标签**\n\n  使用场景需要提交一些信息到服务端的时候（前后端联调过程中）\n\n  + 核心元素input（核心元素）`<input type=\"text\">`表示一个基本的文本框\n\n  + label（提高交互体验的）\n\n    ```\n    第一种\n    <label>\n       <input type=\"checkbox\">同意\n    </label>\n    第二种\n    <label for=\"\">同意</label>\n    <input type=\"checkbox\" id=\"isagree\">\n    ```\n\n  + select（下拉框）\n\n    ```\n    <select>\n       <option value=\"1\">男</option>\n       <option value=\"2\">女</option>\n    </select>\n    ```\n\n    \n\n  + textarea（文本域）\n\n  + button（按钮）\n\n    ```\n    <button type=\"submit\">注册</button> 点击网页的这个按钮就讲这个传给form 后面的action给后台\n    ```\n\n    \n\n  + form（表氮元素，提交每个表单项内容）\n\n* **区块和行内标签**\n\n  + div元素(用的很多)\n\n    + div元素是块级元素，他可以用于组合其他HTML元素的容器\n    + div元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行\n    + 如果与CSS一同使用，div元素可以用于对打的内容块设置样式属性\n    + div元素的另一个藏剑的用途是文档布局\n\n  + span元素（用的很多）\n\n    + span元素是行内元素，可以作为文本的容器\n    + span元素也没有特定的含义\n    + 当与CSS一同使用时，span元素可用于为部分文本设置样式属性\n\n  + 块级元素\n\n    + 块级元素在浏览器显示时，通常会以新行来开始（和结束）\n\n      `<h1><p><ul><table><div>`\n\n  + 行内元素\n\n    + 行内元素在显示时通常不会以新行开始\n\n      `<b><td><a><img><span>`\n\n## CSS\n\n##### CSS基础知识\n\n* **基础规则**\n  + 选择器：告诉浏览器要设置样式的html元素\n  + 声明块：用于设置样式\n  + 层叠样式表（相同的设计最后一个会覆盖前面的设计）\n  + Viewport：将网页的视口设置为完美视口，开发移动端页面时一定要加上\n* **CSS的几种推荐写法**\n  + 写法\n    + 內部样式表：写在元素的style标签里面的\n    + 内联样式表：写在div 里的styles属性里面的\n    + 外部样式表：link标签将css资源引入\n  + 为什么采用外部样式表\n    + 解决页面当中样式重复的问题\n    + 代码分离，利于代码维护和阅读\n    + 浏览器会缓存起来，提高页面相应速度变快了\n\n##### CSS核心技术\n\n* 选择器的选择\n\n  + 元素（标签）选择器\n\n    `组合选择器：h1,p{color:red;}`当属性相同时可以节省很多代码行\n\n  + 类选择器\n\n    + 结合标签选择器\n\n      ```h1.xiaodi{color:red;}\n      在div里声明class <div class=\"yzp\">余贞佩</div>\n      则可以在style下用.yzp{}编辑属性\n      <p class=\"yzp\">余贞佩</p>\n      可以用p.yzp{}进行编辑\n      ```\n\n    + 多类选择器\n\n      ```class=\"yzp background\"\n      <div class=\"yzp background\">余贞佩</div>\n      可在style下.class{}和.background{}进行编辑如果使用.background.yzp{}的话在编辑内容里面必须包含两个\n      ```\n\n  + id选择器\n\n    ```\n    声明：#important{}\n    属性：id=\"important\"\n    \n    注意：一个id选择器的属性值在html文档中只能出现一次，避免写js获取id时出现混淆\n    ```\n\n   + 通配符选择器\n\n     将所有的都修改但优先级很低\n\n   + 派生选择器\n\n     + 后代选择器\n\n       ```\n       h1 p{color:red;}\n       <h1>\n          <p>余贞佩</h>\n       </h1>只要是h1下p中相同的标签都可以修改\n       ```\n\n     + 子元素选择器\n\n       ```\n       h1>p{}表示修改h1中的p标签而不修改h2\n       <h1>\n          <p>余贞佩</p>\n       </h1>\n       <h2>\n          <p>余贞佩</p>\n       </h2>\n       ```\n\n      + 相邻选择器(兄弟选择器)\n\n        `h1+p{background-color:pink;}`\n\n        必须要有相同的父级才能修改，但是是从第二个开始\n\n* 特殊的选择器\n\n  1. 伪类选择器\n\n  + 不改变任何DOM内容。只是插入了一些修饰类的元素\n    ![](C:\\Users\\阿余\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220803180725240.png)\n\n2. 伪元素选择器\n\n```\n::first-letter  //第一个元素\n::first-line  //第一行 只能用于块级元素\n::selection  //选中\n::before   //在开始位置\n::after  //在结束位置\n```\n\n##### CSS基础概念之盒子模型\n\n1. 盒子的内边距（padding）\n\n   ![](C:\\Users\\阿余\\AppData\\Roaming\\Typora\\typora-user-images\\盒子的内边距.png)\n\n2. 盒子的边框（border）（宽度，样式，颜色）\n\n   ![](C:\\Users\\阿余\\AppData\\Roaming\\Typora\\typora-user-images\\盒子的边框.png)\n\n3. 盒子的外边距（margin）\n\n   ![](C:\\Users\\阿余\\AppData\\Roaming\\Typora\\typora-user-images\\盒子的外边距.png)\n\n   * 盒子怪异模型 \n\n     + W3C标准盒子模型（标准盒模型）变大\n\n       `boxWitdth=contentWidth`\n\n     + IE标准盒子模型（怪异盒模型）图片不改变时使用，外边框不改变\n\n       `box-sizing:，border-box`//声明\n\n       `boxWidth=contentWidth+border+padding`\n\n   * 外边距折叠\n\n     + 上下两个兄弟盒子的margin都为正则取大，都为负则取小，一正一负两者相加\n\n     + 父子元素盒子的margin（假设没有内边距或边框那外边距分隔开），也会合并；只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对之间的外边距不会合并\n\n       ```\n       解决父子边距合并：\n       父元素{\n        overflow:auto;\n       }\n       父元素::before{\n          display:table;\n          content:\"\";\n       }\n       ```\n\n* **CSS的常用属性 **\n\n  + 盒子的位置和大小\n\n    ```\n    宽度 width: 长度|百分比|auto\n    高度 height\n    边界 margin padding 上右下左|上下左右\n    ```\n\n   + 布局\n\n     ```\n     浮动： float\n     定位：position\n     弹性布局：flex\n     盒子内容超出部分：overflow:hidden|scroll|auto   隐藏|滑动|滑动\n     ```\n\n    + 外观、风格\n\n      ```\n      background-image: url('图片地址');\n      background-repeat: no-repeat\n      background-size:100%|50%\n      background-position:center|bottom\n      background-color: red;\n      background: red url('') no-repeat center;\n      background-size:100%;\n      ```\n\n     + 文字属性\n\n       ```\n       font-size  字体大小\n       font-weight  是否加粗\n       font-style  是不是斜体\n       font-family  字体是什么\n       ```\n\n* **CSS的层叠与选择器优先级**\n\n  + CSS全称：层叠样式表表（Cascading Style Sheets）\n\n  + 层叠是一个基本特征\n\n    一个css属性被多次声明的时候，会根据优先级或者声明顺序来计算采用哪个样式\n\n  + 优先级怎么计算\n\n    + 通配符选择器1：*\n\n    + 标签选择器2：div  span  p  li\n\n    + 类选择器3： class\n\n    + ID选择器4： ID\n\n    + 行内样式5  <div style=\"color:pink\">内容</div>>是直接在标签里\n\n    + ！impoant6（尽量不要再公用代码里使用）\n\n      注意：1是最低级往下升高\n\n+ **CSS常见的继承属性**\n\n  + 什么是继承\n\n    + 继承了父元素的某些特征\n    + 优点：继承可以简化代码，便于维护\n\n  + 默认设置继承的属性\n    文字属性，文本缩进，对齐，行高\n\n    ```\n    文本缩进 text-indent:50px(为正表示向右，为负向左移)\n    对齐  text-align: right(向右对齐)\n    行高 line-height:50px;\n    ```\n\n+ **CSS布局定位**\n\n  + 前置知识\n\n    + 正常元素的布局\n      1. 默认，一个块级元素的内容宽度就是其父元素的100%，它的高度与其内容高度一致\n      2. 行内元素他的高度和宽度都是根据内容决定的（无法设置行内元素的宽高）\n         + 可设置display属性将行内元素设置为块级元素，定义元素类型（Css3定义布局）\n    + 元素之间如何相互影响\n      + 正常的文档布局流\n        + 每个块级元素会在上一个元素下面另起一行\n        + 行内元素不会另起一行\n\n  + **CSS中float布局**（实现左右布局）\n\n    + float布局\n\n      ```\n      float:none;  //默认值，元素不浮动\n      float:left;  //元素向左浮动\n      float:rght;   //元素向有浮动\n      ```\n\n    + 特点\n\n      + 浮动元素会脱离文档流，不再占用文档流空间\n      + 浮动元素彼此之间是从左往右排列，宽度超过一行自动换行\n      + 在浮动元素前面元素不浮动时，浮动无法上移\n      + 块级元素和行内元素浮动之后都变成行内块级元素\n      + 浮动元素不会盖住文字，可以设置文字环绕效果\n\n    + 清除浮动\n\n      ```\n      在伪元素里设置\n      .box::after{\n      clear:both;\n      content='';\n      display:block;\n      }\n      ```\n\n  + **CSS中flex布局**（弹性布局）\n\n    + 父元素容器的属性\n\n    ```\n    1.父级设置为flex布局以后，子元素的float、clear和vertical-algin属性将失效\n    display：flex；\n    2.决定主轴的方向（即项目的排列方向）\n    flex-direction：row|row-reverse|column|column-reverse（水平方向|相反|垂直方向|相反）\n    3.是否换行\n    flex-wrap：nowrap|wrap|wrap——reverse（不换行|换行|颠倒换行）\n    4.定义水平方向对齐（用的很多）\n    justify-content：flex-end|center|space-between|space—around（从主轴右边开始|居中放在中间|两边占完，且中间居中|左右有距离边框，其余子元素的间距是两边元素距离边框距离的两倍）\n    5.定义垂直方向对齐\n    align—items：flex-end|center|baseline|stretch；（从反方向开始|居中|需要在子元素中添加line—height|需要把子元素中的height去掉，即去掉高度占满竖直方向）\n    6.定义多个轴线（多行、多列）对齐方式\n    align-content:flex-start|flex-end|center|space-between|space-around|stretch;(从上开始|从下往上|居中|)\n    ```\n\n    + 子元素容器属性\n\n      ```\n      1.定义子元素的排列顺序，默认为0\n      order：-10|-1|0|1|10;(越小越靠前，越大越靠后，没设置则默认为零)\n      2.定义子元素的放大比例，默认为0\n      flex-grow:0|1|2|3;(当设置为0时，若容器没满则不占据剩余的容器空间，若设置为1，则会把空间占满)\n      3.定义子元素的缩小比例，默认为1（则会被缩小）\n      flex-shrink:0|1;\n      4.定义在分配多余空间之前，项目占据的主轴空间（设置宽度）\n      flex-basis:<length>|auto;\n      5.flex-grow,flex-shrink和flex-basis的简写(推荐)\n      flex:0   1  auto;\n      兼容性\n      需要浏览器ie9以上\n      ```\n\n  + 怎么选择float和flex\n\n    + 推荐使用flex布局\n      1. flex布局易用，布局全面\n      2. float的创建初衷只是为了达到文字环绕的效果，另外需要清除浮动\n      3. 现在几乎所有的公式参评使用场景都在浏览器IE9以上\n\n+ **CSS中的position定位**\n\n  + 是为了布局引入的属性\n\n  + position常用的几个值\n\n    ```\n    position: static （静态定位） 父元素（默认值）\n    position: relative （相对定位） 父元素\n    position: absolute （绝对定位） 父元素（会寻找父级的relative）\n    \n    \n    position: fixed（固定定位） 父元素（固定在页面位置不动）\n    position: sticky （粘性定位） 父元素（当下滑快到下面时会在顶部不会消失）\n    \n    ```\n\n   + 相关属性\n\n     `z-index  //使用场景：当定位的盒子重叠在一起（即谁优先展示）`\n\n+ **CSS三栏布局如何实现**\n\n  + 问题：高度固定，左右两侧的盒子宽度为200px，中间自适应\n  + 解决方法\n    + float（中间的放在最下面）\n    + position（absolute，左右为零，中间放在下面）\n    + flex（中间的flex ： 1;）（最方便）\n\n+ **CSS实现水平垂直居中**\n\n  + 行内块元素（在span中display:inline-block）\n\n    ```\n    1.line-height:为行内块的height\n      text-align: center\n    2.display:flex;常用\n    justify-content:center\n    align-items:center\n    ```\n\n   + 块级元素\n\n     ```\n     1.position+margin(自身的子元素的-一半)清楚子元素的宽高\n     2.position+transform（transform:translate(--50%,-50%)）不清楚子元素的宽高\n     3.flex\n     4.table-cell兼容性差\n     ```\n\n+ **CSS高级知识点BFC**\n\n  + 定义\n    + 块格式化上下文：是web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域\n    + 即：形成了一块封闭的区域，能检测到区域内脱离文档流的元素\n  + 特点\n    + CSS中隐含的属性，开启后不会被浮动的元素覆盖\n    + BFC元素可以包含浮动元素\n    + BFC元素的子元素和父元素外边距不重叠\n  + 开启（都会有副作用）\n    + 设置元素浮动float：left\n    + 设置为行内块元元素display：inline-block\n    + overflow：hidden（推荐）\n  + 作用\n    + 清除浮动带来的影响\n    + 解决边距塌陷问题（外边距折叠也只会发生在属于同一BFC的块级元素之间）\n\n+ **CSS边框**\n\n  + 圆角\n\n    `border-radius:10px 10px 10px 10px左上 右上 右下 左下（即顺时针）`\n\n  + 盒阴影\n\n    `box-shadow：10px 10px 10px 颜色（左右平移|上下平移|阴影程度|阴影颜色）`\n\n  + 边界图片\n\n    `border-image`\n\n+ **CSS渐变**\n\n  + 基本语法\n\n    ```\n    1.background-image: linear-gradient(颜色，颜色)从上到下渐变（默认）\n    2.background-image: linear-gradient(to right,颜色，颜色)从左到右渐变\n    3.background-image: linear-gradient(to bottom right，颜色，颜色)对角线渐变\n    ```\n\n  + 角度变化也是，180是从上往下，90是左往右，0是下往上\n\n  + 多个颜色同样按上面的\n\n  + 透明度（用的最多）\n\n    `background-image: linear-gradient(rgba(255,0,0,0),rgba(255,0,0,1))`rgba()里面的前三个值时颜色的值，最后一个的值1是不透明，0是透明，最后一个值表示透明度\n\n  + 重复\n\n    `background-image: repeating-linear-gradient(red,yellow 10%,green 20%)`1除以10%表示重复十个，1除以20%表示重复五个\n\n+ **CSS文本效果**\n\n  + 文本阴影\n\n    `text-shadow:5px 5px 5px 颜色(水平方向|垂直方向|阴影程度|阴影颜色)`\n\n  + 文本溢出\n\n    ```\n    1.超出一行省略\n    \n    overflow：hidden\n    \n    white—space：nowrap\n    \n    text-overflow：cellispsis |clip(表示省略号|裁剪)\n    \n    2.超出两行省略\n    overflow:hidden\n    text-overflow:cellispsis\n    -webkit-box-orient:vertical;\n    -webkit-line-clamp:2;\n    ```\n\n  + 文本换行\n\n    + 长文本换行\n\n      `word-wrap:break-word`\n\n    + 单词拆分换行\n\n      `word-break:break-all`\n\n+ **CSS3网格布局**\n\n  + flex布局，float布局应用于一维布局，网格布局应用于二维布局\n\n  + 父元素属性\n\n    ```\n    1.使用\n    display: grid\n    grid-template-columns:10px 10px 10px;\n    grid-template-rows:10px 10px 10px;表示三行三列\n    2.百分比使用\n    display: grid\n    grid-template-columns:33% 33% 33%;\n    grid-template-row:33% 33% 33%;表示三行三列\n    3.repeat()函数简化\n    display: grid\n    grid-template-columns:repeat(3,33.33%)\n    grid-template-row:repeat(3,33.33%);表示三行三列\n    ```\n\n* **项目实战**\n\n  + <link rel=\"shortcut icon\" href=\"图片地址\" type=\"image/x-icon\">图标\n\n  + link:css 可以导入CSS模板\n\n  + 阿里巴巴矢量库:\n\n  + 引入第三方icon\n\n    ```\n    //根文件html导入\n    `<script src=\"http:复制的地址\"></script>`\n    //使用\n    <svg class=\"icon\" aria-hidden=\"true\">\n        <use xlink:href=\"#xxx\"></use>\n    </svg>\n    ```\n\n    \n\n    ","tags":["HTML和CSS"]}]